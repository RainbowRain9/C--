// Source : https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/
// Date   : 2024-11-11

/**************************************************
 * 给你一个整数数组 nums 和两个正整数 m 和 k 。
 *
 * 请你找出 nums 中长度为 k 的所有子数组，请你在这些子数组中找出元素各不相同的子数组的数目 至少为 m 个的子数组。
 * 在满足条件的子数组中，找出元素和的最大值。
 *
 * 如果不存在满足条件的子数组，返回 0 。
 *
 * 子数组是数组中的一个连续元素序列。
 *
 * 示例 1：
 *   输入：nums = [2,6,7,3,1,7], m = 3, k = 4
 *   输出：18
 *   解释：总共有 3 个长度为 4 的子数组，元素各不相同：
 *   - nums[0..3] = [2,6,7,3]，元素和为 18
 *   - nums[1..4] = [6,7,3,1]，元素和为 17
 *   - nums[2..5] = [7,3,1,7]，元素和为 18
 *   其中有 3 个子数组的元素各不相同，所以 m = 3 的条件满足。
 *   在这些子数组中，最大的元素和为 18 。
 *
 * 示例 2：
 *   输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3
 *   输出：23
 *   解释：总共有 5 个长度为 3 的子数组：
 *   - nums[0..2] = [5,9,9] ，元素和为 23
 *   - nums[1..3] = [9,9,2] ，元素和为 20
 *   - nums[2..4] = [9,2,4] ，元素和为 15
 *   - nums[3..5] = [2,4,5] ，元素和为 11
 *   - nums[4..6] = [4,5,4] ，元素和为 13
 *   其中有 3 个子数组的元素各不相同。
 *   在元素各不相同的子数组中，最大的元素和为 23 。
 *
 * 提示：
 *   - k <= nums.length <= 105
 *   - 1 <= m <= k <= nums.length
 *   - 1 <= nums[i] <= 109
 **************************************************/

/*
    解题思路：
    1. 使用滑动窗口法，维护一个长度为k的窗口
    2. 使用哈希表统计窗口内不同元素的个数
    3. 窗口向右滑动时:
       - 移除左边元素时，更新哈希表计数
       - 添加右边元素时，更新哈希表计数
    4. 当窗口内不同元素个数大于等于m时，更新最大和

    时间复杂度分析：
    - 只需要遍历数组一次，时间复杂度为 O(n)
    - 使用哈希表存储窗口内元素，空间复杂度为 O(k)
*/

#include <vector>
#include <unordered_map>
#include <iostream>
using namespace std;

class Solution {
public:
    // 计算满足条件的子数组的最大元素和
    // nums: 输入数组
    // m: 要求的不同元素个数下限
    // k: 子数组长度
    long long maxSum(vector<int> &nums, int m, int k) {
        long long ans = 0;  // 记录最大和
        long long sum = 0;  // 当前窗口内元素和
        unordered_map<int, int> cnt;  // 统计窗口内每个数字出现的次数
        
        // 先将前k-1个数加入窗口
        for (int i = 0; i < k - 1; i++) {
            sum += nums[i];  // 累加元素和
            cnt[nums[i]]++;  // 更新计数
        }

        // 滑动窗口,每次右边界向右移动一位
        for (int i = k - 1; i < nums.size(); i++) {
            // 窗口右边新增一个数
            sum += nums[i];  // 将新数加入元素和
            cnt[nums[i]]++;  // 更新新数的计数
            
            // 如果窗口内不同数字个数达到要求,更新答案
            if (cnt.size() >= m) {
                ans = max(ans, sum);
            }

            // 窗口左边移除一个数
            int out = nums[i - k + 1];  // 要移出的数
            sum -= out;  // 从元素和中减去
            if (--cnt[out] == 0) {  // 更新计数,如果计数变为0则从哈希表中删除
                cnt.erase(out);
            }
        }

        return ans;  // 返回最大和
    }
};

int main() {
    Solution s;
    
    // 测试用例1
    vector<int> nums1 = {2, 6, 7, 3, 1, 7};
    cout << s.maxSum(nums1, 3, 4) << endl;  // 输出: 18

    // 测试用例2 
    vector<int> nums2 = {5, 9, 9, 2, 4, 5, 4};
    cout << s.maxSum(nums2, 1, 3) << endl;  // 输出: 23

    return 0;
}
