{"data":[{"name":"2024-11-19 13:01:24","id":1731992484333,"body":"这道题目是一个滑动窗口的经典应用。让我来详细解释这个解决方案：\r\n\r\n### 解题思路\r\n\r\n1. **问题转化**\r\n   - 题目要求找到包含每个字符至少k次的最短子序列\r\n   - 可以转化为：从字符串两端取字符，找到最少需要取多少个字符\r\n   - 进一步转化为：在中间找最长的连续子串，使得剩余的字符仍然满足每个字符至少k个\r\n\r\n2. **算法步骤**\r\n   ```cpp\r\n   1. 首先统计整个字符串中每个字符的出现次数\r\n   2. 检查是否有可行解（每个字符是否都至少有k个）\r\n   3. 使用滑动窗口找到最长的中间子串，使得移除这个子串后剩余的字符仍满足条件\r\n   4. 最终答案 = 总长度 - 最长中间子串长度\r\n   ```\r\n\r\n3. **代码关键点解释**\r\n   ```cpp:算法训练/LeetCode/All/2516-每种字符至少取 K 个.cpp\r\n   // ... existing code ...\r\n   \r\n   // 统计每个字符的出现次数\r\n   int cnt[3]{};\r\n   for (char c : s) {\r\n       cnt[c - 'a']++;\r\n   }\r\n   \r\n   // 检查可行性\r\n   if (cnt[0] < k || cnt[1] < k || cnt[2] < k) {\r\n       return -1;\r\n   }\r\n   \r\n   // 滑动窗口寻找最长中间子串\r\n   int left = 0, ans = 0;\r\n   for (int right = 0; right < n; right++) {\r\n       cnt[s[right] - 'a']--;  // 从窗口中减去右边界字符\r\n       \r\n       // 如果某个字符数量不足k，就需要缩小窗口\r\n       while (cnt[s[right] - 'a'] < k) {\r\n           cnt[s[left] - 'a']++;  // 将左边界字符加回计数\r\n           left++;\r\n       }\r\n       ans = max(ans, right - left + 1);  // 更新最长子串长度\r\n   }\r\n   \r\n   // ... existing code ...\r\n   ```\r\n\r\n### 时间复杂度\r\n- O(n)，其中n是字符串长度\r\n- 虽然有两个循环，但右指针最多移动n次，左指针也最多移动n次\r\n\r\n### 空间复杂度\r\n- O(1)，只使用了固定大小的数组来存储计数\r\n\r\n这个解法巧妙地使用了滑动窗口来找到可以不选择的最长子串，从而得到需要选择的最少字符数。"}]}