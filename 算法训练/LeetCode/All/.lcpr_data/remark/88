{"data":[{"name":"2024-11-25 20:29:17","id":1732537757951,"body":"\r\n\r\n```thinking\r\n让我深入分析这道经典的双指针题目...\r\n\r\n首先理解题目的关键点：\r\n1. 两个数组都已经排序\r\n2. nums1有足够空间容纳nums2\r\n3. 需要原地合并，不能使用额外空间\r\n\r\n解题的关键思路：\r\n1. 为什么要从后往前？\r\n   - 避免覆盖nums1中的有效元素\r\n   - 利用nums1后面的空间\r\n\r\n2. 三个指针的作用：\r\n   - p1：nums1有效元素的位置\r\n   - p2：nums2的位置\r\n   - p：合并结果的位置\r\n\r\n让我组织一个详细的讲解...\r\n```\r\n\r\n# 88. 合并两个有序数组\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 给定两个有序数组 nums1 和 nums2\r\n- nums1 有足够空间容纳 nums2\r\n- 将 nums2 合并到 nums1 中，使合并后的数组有序\r\n- 要求原地修改，不返回值\r\n\r\n### 2. 关键概念\r\n- 有序数组合并\r\n- 原地修改\r\n- 从后往前处理\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：\r\nnums1 = [1,2,3,0,0,0], m = 3\r\nnums2 = [2,5,6],       n = 3\r\n\r\n过程：\r\n[1,2,3,0,0,6]  ← 先放入6\r\n[1,2,3,0,5,6]  ← 再放入5\r\n[1,2,3,3,5,6]  ← 放入3\r\n[1,2,2,3,5,6]  ← 放入2\r\n完成！\r\n\r\n输出：[1,2,2,3,5,6]\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：\r\nnums1 = [1], m = 1\r\nnums2 = [], n = 0\r\n\r\n输出：[1]\r\n解释：nums2为空，nums1保持不变\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n- 使用三个指针从后往前遍历\r\n- 比较两个数组的元素，取较大值放入结果位置\r\n- 处理剩余元素\r\n\r\n### 2. 具体流程\r\n1. 初始化三个指针：\r\n   - p1 = m - 1 (nums1的有效元素末尾)\r\n   - p2 = n - 1 (nums2的末尾)\r\n   - p = m + n - 1 (合并后的末尾)\r\n\r\n2. 从后往前合并：\r\n   - 比较nums1[p1]和nums2[p2]\r\n   - 取较大值放入nums1[p]\r\n   - 移动对应指针\r\n\r\n3. 处理剩余元素：\r\n   - 如果nums2还有剩余，继续放入nums1\r\n   - nums1剩余元素已经在正确位置\r\n\r\n## 四、代码详解\r\n\r\n```cpp:算法训练/LeetCode/All/88-合并两个有序数组.cpp\r\nclass Solution {\r\npublic:\r\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        // 初始化三个指针\r\n        int p1 = m - 1;    // nums1有效元素的末尾\r\n        int p2 = n - 1;    // nums2的末尾\r\n        int p = m + n - 1; // 合并后的末尾位置\r\n\r\n        // 从后往前合并\r\n        while (p2 >= 0) {  // 只要nums2还有元素未合并\r\n            if (p1 >= 0 && nums1[p1] > nums2[p2]) {\r\n                nums1[p] = nums1[p1];  // 取nums1的元素\r\n                p1--;\r\n            } else {\r\n                nums1[p] = nums2[p2];  // 取nums2的元素\r\n                p2--;\r\n            }\r\n            p--;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n### 代码执行过程示例\r\n以 nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 为例：\r\n```\r\n初始状态：[1,2,3,0,0,0] [2,5,6]\r\n第一步：  [1,2,3,0,0,6] p1=2, p2=1, p=4\r\n第二步：  [1,2,3,0,5,6] p1=2, p2=0, p=3\r\n第三步：  [1,2,3,3,5,6] p1=1, p2=0, p=2\r\n第四步：  [1,2,2,3,5,6] p1=1, p2=-1, p=1\r\n完成！\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- 从后往前合并避免了覆盖问题\r\n- 每次选择较大的数放入末尾，保证了有序性\r\n- 当nums2处理完时，nums1剩余部分已经在正确位置\r\n\r\n### 2. 重要细节\r\n- 指针初始化位置的选择\r\n- while循环的终止条件选择p2\r\n- p1 >= 0的判断条件很重要\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(m + n)\r\n  - 只需要遍历一次两个数组\r\n- **空间复杂度**: O(1)\r\n  - 只使用了三个指针，常数空间\r\n\r\n## 七、常见错误\r\n\r\n1. **从前往后合并**\r\n```cpp\r\n// 错误示例：会覆盖nums1中的元素\r\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n    int i = 0, j = 0;\r\n    while (i < m && j < n) {\r\n        // 这样会覆盖nums1中的元素\r\n    }\r\n}\r\n```\r\n\r\n2. **使用额外空间**\r\n```cpp\r\n// 不符合题目要求的解法\r\nvector<int> temp(nums1);\r\n// 使用临时数组来合并\r\n```\r\n\r\n## 八、相关题目\r\n- [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)\r\n- [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)\r\n\r\n这些题目都涉及有序数组的操作和双指针技巧。"}]}