{"data":[{"name":"2024-11-27 13:54:03","id":1732686843432,"body":"\r\n\r\n```thinking\r\n让我来分析一下这道合并有序数组的题目...\r\n\r\n这是一个很经典的双指针题目，但有一个特别之处：要求原地合并到nums1中。这就带来了一个关键思考点：\r\n\r\n1. 为什么要从后往前合并？\r\n- nums1后面有空间可以直接使用\r\n- 从前往后会覆盖nums1的原有元素\r\n- 从后往前可以避免额外空间\r\n\r\n2. 关键点分析：\r\n- 两个数组都是有序的（升序）\r\n- nums1有足够空间容纳所有元素\r\n- 需要处理其中一个数组用完的情况\r\n\r\n3. 边界情况：\r\n- nums2为空时不需要合并\r\n- nums1为空时直接把nums2复制过来\r\n- 两个数组长度相等的情况\r\n\r\n4. 实现细节：\r\n- p指向nums1有效元素末尾\r\n- q指向nums2末尾\r\n- k指向合并后的位置\r\n- 注意指针不要越界\r\n\r\n这个解法的优点是：\r\n- 时间复杂度O(m+n)\r\n- 空间复杂度O(1)\r\n- 不需要额外数组\r\n- 代码简洁优雅\r\n```\r\n\r\n# 88.合并两个有序数组\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 将两个有序数组nums1和nums2合并\r\n- 合并结果必须存储在数组nums1中\r\n- nums1有足够空间（m + n）容纳两个数组的所有元素\r\n- 需要原地合并，不能使用额外空间\r\n\r\n### 2. 关键概念\r\n- 有序数组合并\r\n- 原地算法\r\n- 双指针技巧\r\n- 从后向前遍历\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\r\n输出：[1,2,2,3,5,6]\r\n解释：\r\n1. 比较3和6，选择6放入末尾\r\n2. 比较3和5，选择5放入\r\n3. 比较3和2，选择3放入\r\n4. 比较2和2，选择2放入\r\n5. 比较1和2，选择2放入\r\n6. 最后放入1\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\r\n输出：[1]\r\n解释：nums2为空，nums1保持不变\r\n```\r\n\r\n### 3. 边界情况\r\n```\r\n输入：nums1 = [0], m = 0, nums2 = [1], n = 1\r\n输出：[1]\r\n解释：nums1为空，直接将nums2的元素放入nums1\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n- 使用从后向前的双指针法\r\n- 避免覆盖nums1中的有效元素\r\n- 每次选择较大的元素放入末尾\r\n\r\n### 2. 具体流程\r\n1. 初始化三个指针：\r\n   - p指向nums1有效元素末尾（m-1）\r\n   - q指向nums2末尾（n-1）\r\n   - k指向合并后的末尾（m+n-1）\r\n2. 从后向前比较元素并合并\r\n3. 处理剩余元素\r\n\r\n## 四、代码详解\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        int p = m - 1;    // nums1有效元素末尾\r\n        int q = n - 1;    // nums2末尾\r\n        int k = m + n - 1;  // 合并后的末尾\r\n        \r\n        // 从后向前合并\r\n        while (q >= 0) {  // 只要nums2还有元素\r\n            if (p >= 0 && nums1[p] > nums2[q]) {\r\n                nums1[k--] = nums1[p--];  // 选择nums1的元素\r\n            } else {\r\n                nums1[k--] = nums2[q--];  // 选择nums2的元素\r\n            }\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- 从后向前合并不会覆盖未处理的元素\r\n- 每次选择较大的元素保证有序性\r\n- 当nums2处理完时，nums1剩余元素已经在正确位置\r\n- 所有元素都会被处理到\r\n\r\n### 2. 重要细节\r\n- 指针初始化位置的计算\r\n- 循环条件的选择\r\n- 比较时需要检查p >= 0\r\n- 不需要专门处理nums1剩余元素\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(m + n)\r\n  - 最多遍历两个数组各一次\r\n  - 每个元素最多被移动一次\r\n- **空间复杂度**: O(1)\r\n  - 只使用了三个指针\r\n  - 原地修改数组\r\n\r\n## 七、常见错误\r\n\r\n1. **从前向后合并**\r\n```cpp\r\n// 错误代码：会覆盖nums1中的元素\r\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n    int i = 0, j = 0, k = 0;\r\n    while (i < m && j < n) {\r\n        if (nums1[i] <= nums2[j]) {\r\n            nums1[k++] = nums1[i++];\r\n        } else {\r\n            nums1[k++] = nums2[j++];\r\n        }\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n2. **边界条件处理错误**\r\n```cpp\r\n// 错误代码：没有检查p >= 0\r\nwhile (q >= 0) {\r\n    if (nums1[p] > nums2[q]) {  // p可能为负数\r\n        nums1[k--] = nums1[p--];\r\n    } else {\r\n        nums1[k--] = nums2[q--];\r\n    }\r\n}\r\n```\r\n\r\n## 八、相关题目\r\n- [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)\r\n- [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)\r\n\r\n---\r\n\r\n这道题的关键点是：\r\n1. 从后向前合并避免覆盖\r\n2. 正确处理指针移动\r\n3. 注意边界条件\r\n4. 利用nums1的空余空间\r\n\r\n理解这种从后向前处理的思路对解决类似的数组原地修改问题很有帮助。"}]}