{"data":[{"name":"2024-11-19 20:54:53","id":1732020893943,"body":"\r\n\r\n# LeetCode 2762 - 不间断子数组\r\n\r\n```thinking\r\n让我深入分析这道题...\r\n\r\n首先理解核心概念：\r\n- \"不间断子数组\"的定义：相邻元素差的绝对值不超过2\r\n- 这意味着数组中任意两个相邻数的差值要在[-2,2]范围内\r\n- 换个角度看，就是子数组中最大值和最小值的差不能超过2\r\n\r\n解题思路的关键点：\r\n- 这是一个需要维护区间最大最小值的问题\r\n- 可以用滑动窗口配合有序集合（map）来解决\r\n- map可以方便地获取当前窗口的最大值和最小值\r\n\r\n数据结构选择：\r\n- 使用map而不是multiset的原因是map可以直接统计元素个数\r\n- map的key自动排序特性可以让我们方便地获取最大最小值\r\n- begin()和rbegin()可以O(1)时间获取最值\r\n\r\n关于复杂度：\r\n- 时间复杂度应该是O(nlogn)，因为map的插入和删除是O(logn)\r\n- 空间复杂度是O(n)，主要是map的开销\r\n\r\n让我想想特殊情况：\r\n- 单个元素的子数组一定是合法的\r\n- 当数组单调递增且差值<=2时，所有子数组都合法\r\n- 需要用long long因为子数组数量可能很大\r\n\r\n这个思路应该是完整的，让我整理一下详细的解释。\r\n```\r\n\r\n## 题目描述\r\n给你一个整数数组 `nums`，如果一个子数组中的每对相邻元素的差的绝对值小于等于 2，则称这个子数组为**不间断子数组**。返回 `nums` 中所有不间断子数组的数目。\r\n\r\n## 示例分析\r\n### 示例 1\r\n```\r\n输入：nums = [5,4,2,4]\r\n输出：8\r\n解释：不间断子数组有：\r\n- 长度为1的：[5], [4], [2], [4]\r\n- 长度为2的：[5,4], [4,2], [2,4]\r\n- 长度为3的：[4,2,4]\r\n```\r\n\r\n### 示例 2\r\n```\r\n输入：nums = [1,2,3]\r\n输出：6\r\n解释：所有子数组都是不间断的，因为相邻元素差值都是1\r\n```\r\n\r\n## 详细解题思路\r\n### 1. 核心思想\r\n使用滑动窗口配合有序映射（map）来解决问题：\r\n1. map 用来维护当前窗口中的元素及其出现次数\r\n2. 通过 map 可以方便地获取窗口中的最大值和最小值\r\n3. 当最大值和最小值的差超过 2 时，需要收缩左边界\r\n\r\n### 2. 算法流程\r\n1. 初始化：\r\n   - 创建 map 存储窗口内的元素及其频次\r\n   - 使用左指针 left 标记窗口左边界\r\n   - 使用 ans 累计结果\r\n\r\n2. 遍历数组，对于每个右边界：\r\n   - 将当前元素加入 map\r\n   - 检查当前窗口是否合法（最大值和最小值的差是否不超过 2）\r\n   - 如果不合法，收缩左边界直到合法\r\n   - 统计以当前右边界结尾的所有合法子数组数量\r\n\r\n3. 返回最终结果\r\n\r\n### 3. 代码实现\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    long long continuousSubarrays(vector<int>& nums) {\r\n        int n = nums.size();\r\n        map<int, int> cnt;  // 有序映射存储元素及其频次\r\n        int left = 0;  // 左边界\r\n        long long ans = 0;  // 结果\r\n        \r\n        // 遍历每个右边界\r\n        for (int right = 0; right < n; right++) {\r\n            // 加入新元素\r\n            cnt[nums[right]]++;\r\n            \r\n            // 当窗口不合法时，收缩左边界\r\n            while (cnt.rbegin()->first - cnt.begin()->first > 2) {\r\n                int y = nums[left];\r\n                if (--cnt[y] == 0) {\r\n                    cnt.erase(y);\r\n                }\r\n                left++;\r\n            }\r\n            \r\n            // 统计以当前右边界结尾的合法子数组数量\r\n            ans += right - left + 1;\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 4. 代码详解\r\n1. **数据结构**：\r\n   ```cpp\r\n   map<int, int> cnt;  // 键为元素值，值为出现次数\r\n   ```\r\n   - 使用 map 而不是 unordered_map 是因为需要有序性\r\n   - map 可以通过 begin() 和 rbegin() 快速获取最值\r\n\r\n2. **窗口维护**：\r\n   ```cpp\r\n   cnt[nums[right]]++;  // 加入新元素\r\n   while (cnt.rbegin()->first - cnt.begin()->first > 2) {\r\n       // 收缩左边界\r\n   }\r\n   ```\r\n   - rbegin()->first 获取最大值\r\n   - begin()->first 获取最小值\r\n   - 差值大于 2 时需要收缩窗口\r\n\r\n3. **左边界收缩**：\r\n   ```cpp\r\n   int y = nums[left];\r\n   if (--cnt[y] == 0) {\r\n       cnt.erase(y);\r\n   }\r\n   left++;\r\n   ```\r\n   - 减少左边界元素的计数\r\n   - 当计数为 0 时从 map 中删除该元素\r\n   - 移动左边界\r\n\r\n4. **结果统计**：\r\n   ```cpp\r\n   ans += right - left + 1;\r\n   ```\r\n   - right - left + 1 表示以当前右边界结尾的所有合法子数组数量\r\n   - 这是因为从 left 到 right 的任意起点都能形成合法子数组\r\n\r\n## 复杂度分析\r\n- **时间复杂度**：O(nlogn)\r\n  - 遍历数组：O(n)\r\n  - map 的插入和删除操作：O(logn)\r\n  - 总体复杂度：O(nlogn)\r\n\r\n- **空间复杂度**：O(n)\r\n  - map 存储窗口内的元素：最坏情况 O(n)\r\n\r\n## 优化建议\r\n1. 如果数据范围较小，可以考虑使用数组代替 map\r\n2. 如果确定数据不会重复，可以使用 set 代替 map\r\n3. 在特定场景下，可以使用双端队列维护最大最小值\r\n\r\n## 注意事项\r\n1. 使用 long long 类型避免整数溢出\r\n2. 注意 map 删除元素的时机，计数为 0 时及时删除\r\n3. 窗口收缩条件的判断要准确\r\n4. 子数组计数方式的正确性\r\n\r\n## 相关题目\r\n1. LeetCode 239 - 滑动窗口最大值\r\n2. LeetCode 1438 - 绝对差不超过限制的最长连续子数组\r\n3. LeetCode 2537 - 统计好子数组的数目"}]}