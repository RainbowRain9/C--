{"data":[{"name":"2024-12-11 22:40:01","id":1733928001047,"body":"让我按照这个模板来详细讲解这道题。\r\n\r\n# 2337. 移动片段得到字符串\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 给定两个字符串 start 和 target，它们仅由字符 'L'、'R' 和 '_' 组成\r\n- 'L' 和 'R' 表示棋子，'_' 表示空位\r\n- 'L' 只能向左移动到空位，'R' 只能向右移动到空位\r\n- 判断是否能通过移动将 start 变为 target\r\n\r\n### 2. 关键概念\r\n- 移动规则：L只能左移，R只能右移\r\n- 相对顺序：L和R的相对顺序不能改变\r\n- 空位('_')：作为移动的中转位置\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：start = \"_L__R__R_\", target = \"L______RR\"\r\n输出：true\r\n解释：\r\n1. L可以左移一位：_L__R__R_ → L___R__R_\r\n2. 第一个R可以右移三位：L___R__R_ → L______RR\r\n3. 第二个R可以右移一位：L______R_ → L______RR\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：start = \"R_L_\", target = \"__LR\"\r\n输出：false\r\n解释：R必须在L的右侧，不能交换位置\r\n```\r\n\r\n### 3. 边界情况\r\n```\r\n输入：start = \"_R\", target = \"R_\"\r\n输出：true\r\n解释：只有一个棋子的简单移动\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n1. 序列验证：去掉所有'_'后，两个字符串必须相同\r\n2. 位置验证：检查每个字符的移动是否符合规则\r\n   - L只能向左移动（新位置必须在原位置左边）\r\n   - R只能向右移动（新位置必须在原位置右边）\r\n\r\n### 2. 具体流程\r\n1. 预处理：移除两个字符串中的所有'_'并比较\r\n2. 双指针遍历：\r\n   - i指向start中的非'_'字符\r\n   - j指向target中的非'_'字符\r\n   - 验证移动的合法性\r\n\r\n## 四、代码详解\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    bool canChange(string start, string target) {\r\n        // 1. 移除'_'后比较序列\r\n        string s = start, t = target;\r\n        s.erase(remove(s.begin(), s.end(), '_'), s.end());\r\n        t.erase(remove(t.begin(), t.end(), '_'), t.end());\r\n        if (s != t) return false;\r\n        \r\n        // 2. 验证移动合法性\r\n        for (int i = 0, j = 0; i < start.length(); i++) {\r\n            if (start[i] == '_') continue;\r\n            \r\n            while (target[j] == '_') j++;\r\n            \r\n            // 核心判断：位置i和j的关系必须符合移动规则\r\n            if (i != j && (start[i] == 'L') == (i < j)) {\r\n                return false;\r\n            }\r\n            j++;\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n\r\n### 代码优化\r\n关键判断 `(start[i] == 'L') == (i < j)` 可以展开理解为：\r\n```cpp\r\nif (start[i] == 'L' && i < j) return false;  // L不能右移\r\nif (start[i] == 'R' && i > j) return false;  // R不能左移\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- 序列验证确保了L和R的相对顺序不变\r\n- 位置验证确保了每个移动都符合规则\r\n- 双指针遍历保证了所有字符都被正确匹配\r\n\r\n### 2. 重要细节\r\n- 使用erase和remove去除'_'的技巧\r\n- 双指针遍历时跳过'_'的处理\r\n- 移动合法性的简洁判断条件\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(n)\r\n  - 移除'_'操作：O(n)\r\n  - 双指针遍历：O(n)\r\n- **空间复杂度**: O(1)\r\n  - 只使用了常数额外空间\r\n\r\n## 七、常见错误\r\n\r\n1. **忽略序列验证**\r\n```cpp\r\n// 错误：直接进行位置验证\r\nbool canChange(string start, string target) {\r\n    // 缺少序列验证步骤\r\n    for (int i = 0, j = 0; i < start.length(); i++) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n2. **移动规则判断错误**\r\n```cpp\r\n// 错误：判断条件写反\r\nif (i != j && (start[i] == 'L') != (i < j)) {\r\n    return false;\r\n}\r\n```\r\n\r\n## 八、相关题目\r\n- [777. 在LR字符串中交换相邻字符](https://leetcode.cn/problems/swap-adjacent-in-lr-string/)\r\n- [2337. 移动片段得到字符串](https://leetcode.cn/problems/move-pieces-to-obtain-a-string/)\r\n"}]}