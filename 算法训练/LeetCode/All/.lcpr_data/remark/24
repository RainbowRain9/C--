{"data":[{"name":"2024-11-27 16:23:56","id":1732695836080,"body":"\r\n\r\n```thinking\r\n让我来分析一下这道两两交换链表节点的题目...\r\n\r\n这是一个很经典的链表操作题目，需要仔细思考几个关键点：\r\n\r\n1. 为什么要用虚拟头节点？\r\n- 统一处理第一个节点和其他节点\r\n- 避免头节点的特殊处理\r\n- 简化代码逻辑\r\n\r\n2. 需要几个指针？\r\n- p指向待交换对的前一个节点\r\n- p1指向第一个待交换节点\r\n- p2指向第二个待交换节点\r\n- p3指向下一对的起始位置\r\n\r\n3. 每次交换的步骤：\r\n- 保存p2->next到p3\r\n- 调整p2指向p1\r\n- 调整p1指向p3\r\n- 调整p指向p2\r\n\r\n4. 边界情况：\r\n- 空链表\r\n- 只有一个节点\r\n- 节点数为奇数\r\n- 节点数为偶数\r\n\r\n这个解法的精妙之处在于指针的移动和更新非常清晰。\r\n```\r\n\r\n# 24. 两两交换链表中的节点\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 给定一个链表，两两交换其中相邻的节点\r\n- 必须通过修改节点本身，而不是修改节点的值\r\n- 返回交换后的链表\r\n\r\n### 2. 关键概念\r\n- 链表节点交换\r\n- 指针操作\r\n- 虚拟头节点技巧\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：1->2->3->4\r\n输出：2->1->4->3\r\n解释：\r\n1. 交换1,2：2->1->3->4\r\n2. 交换3,4：2->1->4->3\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：[]\r\n输出：[]\r\n解释：空链表不需要交换\r\n```\r\n\r\n### 3. 边界情况\r\n```\r\n输入：1->2->3\r\n输出：2->1->3\r\n解释：最后剩余一个节点不需要交换\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n- 使用虚拟头节点简化操作\r\n- 维护四个关键指针\r\n- 每次交换相邻两个节点\r\n- 更新指针位置\r\n\r\n### 2. 具体流程\r\n1. 创建虚拟头节点dummy\r\n2. 初始化指针：\r\n   - p = dummy\r\n   - p1 = head\r\n3. 循环处理每对节点：\r\n   - 获取p2和p3\r\n   - 执行交换操作\r\n   - 更新指针位置\r\n\r\n## 四、代码详解\r\n\r\n```cpp:算法训练/LeetCode/All/24-两两交换链表中的节点.cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        // 创建虚拟头节点\r\n        ListNode dummy(0, head);\r\n        ListNode* p = &dummy;  // 指向待交换对的前一个节点\r\n        ListNode* p1 = head;   // 指向第一个待交换节点\r\n        \r\n        while (p1 && p1->next) {\r\n            ListNode* p2 = p1->next;      // 第二个待交换节点\r\n            ListNode* p3 = p2->next;      // 下一对的起始节点\r\n            \r\n            // 执行交换\r\n            p->next = p2;    // 前一个节点指向p2\r\n            p2->next = p1;   // p2指向p1\r\n            p1->next = p3;   // p1指向下一对的起始节点\r\n            \r\n            // 更新指针\r\n            p = p1;          // 移动p到下一对的前一个位置\r\n            p1 = p3;         // 移动p1到下一对的起始位置\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n};\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- 每次操作只涉及局部的四个指针\r\n- 交换操作不会丢失节点\r\n- 指针更新保证了遍历完整个链表\r\n- 边界情况（空链表、单节点）都能正确处理\r\n\r\n### 2. 重要细节\r\n- 使用虚拟头节点避免特殊处理\r\n- 保存p3防止链表断开\r\n- 正确更新各个指针\r\n- 循环条件的选择\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(n)\r\n  - 只需要遍历一次链表\r\n  - 每个节点最多被访问一次\r\n- **空间复杂度**: O(1)\r\n  - 只使用了常数个指针\r\n  - 没有使用额外空间\r\n\r\n## 七、常见错误\r\n\r\n1. **没有保存下一对的起始节点**\r\n```cpp\r\n// 错误代码\r\nwhile (p1 && p1->next) {\r\n    ListNode* p2 = p1->next;\r\n    // 没有保存p3 = p2->next\r\n    p->next = p2;\r\n    p2->next = p1;\r\n    // 链表可能断开\r\n    p1->next = ???;\r\n}\r\n```\r\n\r\n2. **指针更新顺序错误**\r\n```cpp\r\n// 错误代码\r\nwhile (p1 && p1->next) {\r\n    ListNode* p2 = p1->next;\r\n    ListNode* p3 = p2->next;\r\n    \r\n    p2->next = p1;   // 过早修改p2->next会丢失p3\r\n    p->next = p2;\r\n    p1->next = p3;\r\n}\r\n```\r\n\r\n## 八、相关题目\r\n- [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)\r\n- [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)\r\n\r\n---\r\n\r\n这道题的关键点是：\r\n1. 使用虚拟头节点简化操作\r\n2. 正确保存和更新指针\r\n3. 理清交换操作的顺序\r\n4. 处理好边界情况\r\n\r\n掌握这道题对于理解链表操作和指针操作都很有帮助。特别是：\r\n- 如何使用虚拟头节点\r\n- 如何在不丢失节点的情况下修改指针\r\n- 如何处理链表的成对操作\r\n\r\n这些技巧在其他链表题目中都很常用。"}]}