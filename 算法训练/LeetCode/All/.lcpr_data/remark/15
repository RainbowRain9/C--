{"data":[{"name":"2024-11-22 21:23:11","id":1732281791129,"body":"\r\n\r\n```thinking\r\n让我组织一下这道题的完整题解...\r\n\r\n需要覆盖以下几个方面:\r\n1. 题目分析 - 关键难点和思路突破\r\n2. 解题思路 - 为什么用排序+双指针\r\n3. 代码实现 - 重点讲解每个部分的作用\r\n4. 优化方案 - 去重和剪枝的必要性\r\n5. 复杂度分析\r\n6. 相关题目引申\r\n\r\n重点要说明:\r\n- 为什么要排序\r\n- 如何避免重复解\r\n- 双指针的移动策略\r\n- 优化的必要性和效果\r\n\r\n需要配合具体例子来说明,让读者更容易理解。\r\n```\r\n\r\n# 三数之和 - LeetCode 15\r\n\r\n## 题目描述\r\n给你一个整数数组 nums，判断是否存在三个元素 a，b，c ，使得 a + b + c = 0。请找出所有和为 0 且不重复的三元组。\r\n\r\n## 解题思路\r\n\r\n### 1. 问题分析\r\n这道题的主要难点在于:\r\n- 需要找到所有可能的组合\r\n- 要求不能包含重复的三元组\r\n- 数组中可能包含重复元素\r\n- 直接暴力三重循环会超时\r\n\r\n### 2. 核心思路\r\n将问题转化为\"固定一个数,寻找另外两个数\"的过程:\r\n1. 先排序,这样可以:\r\n   - 使用双指针降低时间复杂度\r\n   - 方便去除重复解\r\n2. 固定第一个数x,用双指针寻找另外两个数\r\n3. 通过去重和剪枝来优化性能\r\n\r\n### 3. 具体步骤\r\n\r\n#### 3.1 排序预处理\r\n```cpp\r\nsort(nums.begin(), nums.end());\r\n```\r\n排序后数组有序,这是使用双指针的前提。\r\n\r\n#### 3.2 固定第一个数\r\n```cpp\r\nfor (int i = 0; i < n-2; i++) {\r\n    int x = nums[i];\r\n    // 去重\r\n    if (i && x == nums[i-1]) continue;\r\n    // ...\r\n}\r\n```\r\n- 固定第一个数x\r\n- 跳过重复的x以避免重复解\r\n\r\n#### 3.3 双指针查找\r\n```cpp\r\nint j = i+1, k = n-1;\r\nwhile (j < k) {\r\n    int sum = x + nums[j] + nums[k];\r\n    if (sum < 0) j++;      // 和太小,j右移\r\n    else if (sum > 0) k--; // 和太大,k左移\r\n    else {\r\n        ans.push_back({x, nums[j], nums[k]});\r\n        // 跳过重复元素\r\n        for (j++; j < k && nums[j] == nums[j-1]; j++);\r\n        for (k--; k > j && nums[k] == nums[k+1]; k--);\r\n    }\r\n}\r\n```\r\n- j从左向右,k从右向左\r\n- 根据三数之和调整指针位置\r\n- 找到答案后跳过重复元素\r\n\r\n### 4. 优化策略\r\n\r\n#### 4.1 提前退出\r\n```cpp\r\n// 最小的三个数和都大于0,后面不可能有解\r\nif (x + nums[i+1] + nums[i+2] > 0) break;\r\n\r\n// 当前数和最大的两个数和都小于0,这轮循环不可能有解\r\nif (x + nums[n-2] + nums[n-1] < 0) continue;\r\n```\r\n\r\n#### 4.2 去重优化\r\n- 对第一个数x去重\r\n- 找到答案后对j和k去重\r\n- 都是通过和前一个数比较实现\r\n\r\n### 5. 完整代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> threeSum(vector<int>& nums) {\r\n        int n = nums.size();\r\n        sort(nums.begin(), nums.end());\r\n        vector<vector<int>> ans;\r\n        \r\n        for (int i = 0; i < n-2; i++) {\r\n            int x = nums[i];\r\n            if (i && x == nums[i-1]) continue;\r\n            if (x + nums[i+1] + nums[i+2] > 0) break;\r\n            if (x + nums[n-2] + nums[n-1] < 0) continue;\r\n            \r\n            int j = i+1, k = n-1;\r\n            while (j < k) {\r\n                int sum = x + nums[j] + nums[k];\r\n                if (sum < 0) j++;\r\n                else if (sum > 0) k--;\r\n                else {\r\n                    ans.push_back({x, nums[j], nums[k]});\r\n                    for (j++; j < k && nums[j] == nums[j-1]; j++);\r\n                    for (k--; k > j && nums[k] == nums[k+1]; k--);\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 6. 复杂度分析\r\n- 时间复杂度: O(n²)\r\n  - 排序O(nlogn)\r\n  - 双重循环O(n²)\r\n- 空间复杂度: O(1)(不考虑排序的空间消耗和返回值所需空间)\r\n\r\n### 7. 相关题目\r\n- [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)\r\n- [18. 四数之和](https://leetcode.cn/problems/4sum/)\r\n- [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)\r\n\r\n这些题目都可以用类似的排序+双指针思路来解决。"}]}