{"data":[{"name":"2024-11-20 10:34:41","id":1732070081320,"body":"\r\n\r\n# LeetCode 930 - 和相同的二元子数组\r\n\r\n```thinking\r\n让我深入分析这道题...\r\n\r\n首先理解题目核心：\r\n1. 需要找到所有和为goal的连续子数组\r\n2. 数组中只包含0和1\r\n3. 要求子数组的和恰好等于goal\r\n\r\n关键思路分析：\r\n- 这是一个\"恰好等于\"的问题\r\n- 可以转化为\"小于等于\"的问题的差值\r\n- 即：(小于等于goal的数量) - (小于等于goal-1的数量)\r\n- 可以用滑动窗口来维护和的范围\r\n\r\n解题策略：\r\n1. 用两个滑动窗口分别维护：\r\n   - 和小于等于goal的窗口\r\n   - 和小于等于goal-1的窗口\r\n2. 两个窗口的差就是恰好等于goal的数量\r\n\r\n数据结构选择：\r\n- 只需要简单的变量就够了\r\n- 需要用long long避免溢出\r\n\r\n让我想想边界情况：\r\n- goal为0的特殊处理\r\n- 全是0的数组\r\n- 需要考虑单个元素的情况\r\n- 子数组长度的各种可能性\r\n\r\n这个思路应该是完整的，让我整理一下详细解释。\r\n```\r\n\r\n## 题目描述\r\n给你一个二元数组 `nums` 和一个整数 `goal`，请你统计并返回有多少个和为 `goal` 的非空子数组。子数组是数组的一段连续部分。\r\n\r\n## 示例分析\r\n### 示例 1\r\n```\r\n输入：nums = [1,0,1,0,1], goal = 2\r\n输出：4\r\n解释：如下面所示，有 4 个满足题目要求的子数组：\r\n[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\r\n```\r\n\r\n### 示例 2\r\n```\r\n输入：nums = [0,0,0,0,0], goal = 0\r\n输出：15\r\n解释：所有子数组的和都是0，一共有15个子数组。\r\n```\r\n\r\n## 详细解题思路\r\n### 1. 核心思想\r\n使用双指针滑动窗口方法：\r\n1. 维护两个窗口，分别计算：\r\n   - 和小于等于goal的子数组数量\r\n   - 和小于等于goal-1的子数组数量\r\n2. 两者的差值就是和恰好等于goal的子数组数量\r\n\r\n### 2. 算法流程\r\n1. 初始化：\r\n   - 设置两个左指针left1和left2\r\n   - 设置两个和sum1和sum2\r\n   - 使用right指针遍历数组\r\n\r\n2. 对于每个右边界：\r\n   - 更新两个窗口的和\r\n   - 收缩左边界使窗口满足条件\r\n   - 计算当前右边界对应的有效子数组数量\r\n\r\n### 3. 代码实现\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    long long numSubarraysWithSum(vector<int>& nums, int goal) {\r\n        int n = nums.size();\r\n        long long ans = 0;\r\n        \r\n        // 双指针维护两个窗口\r\n        int left1 = 0, left2 = 0;\r\n        int sum1 = 0, sum2 = 0;\r\n        \r\n        for (int right = 0; right < n; right++) {\r\n            // 更新第一个窗口（和<=goal）\r\n            sum1 += nums[right];\r\n            while (left1 <= right && sum1 > goal) {\r\n                sum1 -= nums[left1];\r\n                left1++;\r\n            }\r\n            \r\n            // 更新第二个窗口（和<=goal-1）\r\n            sum2 += nums[right];\r\n            while (left2 <= right && sum2 >= goal) {\r\n                sum2 -= nums[left2];\r\n                left2++;\r\n            }\r\n            \r\n            // 计算当前右边界对应的有效子数组数量\r\n            ans += left2 - left1;\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 4. 代码详解\r\n1. **双指针初始化**：\r\n   ```cpp\r\n   int left1 = 0, left2 = 0;  // 两个左指针\r\n   int sum1 = 0, sum2 = 0;    // 两个窗口的和\r\n   ```\r\n   - left1维护和<=goal的窗口\r\n   - left2维护和<goal的窗口\r\n\r\n2. **第一个窗口维护**：\r\n   ```cpp\r\n   sum1 += nums[right];\r\n   while (left1 <= right && sum1 > goal) {\r\n       sum1 -= nums[left1];\r\n       left1++;\r\n   }\r\n   ```\r\n   - 加入新元素后更新和\r\n   - 当和超过goal时收缩左边界\r\n\r\n3. **第二个窗口维护**：\r\n   ```cpp\r\n   sum2 += nums[right];\r\n   while (left2 <= right && sum2 >= goal) {\r\n       sum2 -= nums[left2];\r\n       left2++;\r\n   }\r\n   ```\r\n   - 类似第一个窗口\r\n   - 但收缩条件是sum2 >= goal\r\n\r\n4. **结果计算**：\r\n   ```cpp\r\n   ans += left2 - left1;\r\n   ```\r\n   - left2-left1表示和恰好等于goal的子数组数量\r\n   - 这是因为[left1,left2)范围内的每个位置作为左端点都能形成一个符合条件的子数组\r\n\r\n## 复杂度分析\r\n- **时间复杂度**：O(n)\r\n  - 每个元素最多被访问常数次\r\n  - 两个指针各自最多移动n次\r\n\r\n- **空间复杂度**：O(1)\r\n  - 只使用了常数额外空间\r\n\r\n## 优化建议\r\n1. 特殊情况优化：\r\n   - 当goal=0时可以特殊处理\r\n   - 当数组全为0时可以直接计算\r\n2. 可以使用前缀和方法解决，但空间复杂度会增加到O(n)\r\n\r\n## 注意事项\r\n1. 使用long long类型避免整数溢出\r\n2. 注意左指针的边界条件(left <= right)\r\n3. 两个窗口的收缩条件不同\r\n4. 结果计算时的指针差值含义\r\n\r\n## 相关题目\r\n1. LeetCode 560 - 和为K的子数组\r\n2. LeetCode 974 - 和可被K整除的子数组\r\n3. LeetCode 1248 - 统计「优美子数组」\r\n\r\n## 扩展思考\r\n1. **前缀和解法**：\r\n   ```cpp\r\n   long long numSubarraysWithSum(vector<int>& nums, int goal) {\r\n       unordered_map<int, int> count;\r\n       count[0] = 1;\r\n       long long ans = 0;\r\n       int sum = 0;\r\n       \r\n       for (int num : nums) {\r\n           sum += num;\r\n           ans += count[sum - goal];\r\n           count[sum]++;\r\n       }\r\n       \r\n       return ans;\r\n   }\r\n   ```\r\n   - 使用哈希表记录前缀和出现次数\r\n   - 时间复杂度O(n)，空间复杂度O(n)\r\n\r\n2. **数学方法**：\r\n   - 对于全0数组且goal=0的情况\r\n   - 可以直接用组合数学公式计算：n*(n+1)/2\r\n   - 但需要注意整数溢出问题\r\n\r\n3. **双指针优化**：\r\n   - 可以在遍历过程中动态调整窗口大小\r\n   - 利用数组只包含0和1的特性优化判断\r\n   - 可以减少一些不必要的计算"}]}