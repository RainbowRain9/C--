{"data":[{"name":"2024-11-29 14:06:05","id":1732860365472,"body":"\r\n\r\n```thinking\r\n让我深入分析一下这道题 - LeetCode 1047 删除字符串中的所有相邻重复项。\r\n\r\n首先理解题目本质：\r\n1. 这是一个字符串处理问题\r\n2. 核心是要找到并删除相邻的重复字符\r\n3. 需要反复进行这个过程直到没有相邻重复项\r\n\r\n解题思路分析：\r\n1. 最直观的想法是用栈\r\n2. 为什么用栈？因为：\r\n   - 需要和前一个字符比较\r\n   - 需要能够回退（删除）\r\n   - 需要保持字符的相对顺序\r\n3. 在C++中可以直接用string模拟栈操作，更高效\r\n\r\n代码实现的关键点：\r\n1. back()获取最后一个字符\r\n2. pop_back()删除最后一个字符\r\n3. push_back()添加新字符\r\n\r\n让我组织一个详细的讲解。\r\n```\r\n\r\n# 1047. 删除字符串中的所有相邻重复项\r\n\r\n## 一、题目要点\r\n\r\n### 1. 问题描述\r\n- 给出一个字符串 S，需要删除所有相邻且相同的字母\r\n- 删除操作需要重复进行，直到无法继续删除\r\n- 返回最终的字符串\r\n\r\n### 2. 示例解析\r\n```\r\n输入：\"abbaca\"\r\n处理过程：\r\n1. \"abbaca\" -> \"aaca\"   (删除bb)\r\n2. \"aaca\"   -> \"ca\"     (删除aa)\r\n最终输出：\"ca\"\r\n```\r\n\r\n## 二、解题思路\r\n\r\n### 1. 栈的应用\r\n使用栈的原因：\r\n- 需要和前一个字符比较\r\n- 需要能够\"撤销\"操作\r\n- 需要保持剩余字符的顺序\r\n\r\n### 2. 具体算法\r\n1. 遍历字符串中的每个字符\r\n2. 对每个字符：\r\n   - 如果栈为空或与栈顶字符不同：入栈\r\n   - 如果与栈顶字符相同：弹出栈顶字符\r\n3. 最终栈中的内容就是结果\r\n\r\n## 三、代码实现\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string removeDuplicates(string s) {\r\n        string stk;  // 用string模拟栈\r\n        \r\n        for (char ch : s) {\r\n            if (!stk.empty() && stk.back() == ch) {\r\n                stk.pop_back();  // 删除栈顶元素\r\n            } else {\r\n                stk.push_back(ch);  // 添加新元素\r\n            }\r\n        }\r\n        \r\n        return stk;\r\n    }\r\n};\r\n```\r\n\r\n## 四、代码详解\r\n\r\n### 1. 关键操作\r\n- `string stk`：用字符串模拟栈，比实际使用`stack`更高效\r\n- `stk.back()`：获取最后一个字符（栈顶）\r\n- `stk.pop_back()`：删除最后一个字符（出栈）\r\n- `stk.push_back(ch)`：添加新字符（入栈）\r\n\r\n### 2. 优化点\r\n- 使用string而不是stack的原因：\r\n  1. string直接就是最终需要的格式\r\n  2. 避免了额外的数据转换\r\n  3. 内存效率更高\r\n\r\n## 五、复杂度分析\r\n\r\n### 1. 时间复杂度：O(n)\r\n- 只需要遍历一次字符串\r\n- 每个字符最多被操作两次（入栈和出栈）\r\n\r\n### 2. 空间复杂度：O(n)\r\n- 最坏情况下需要存储原始字符串的所有字符\r\n- 最好情况是O(1)，当所有字符都被删除时\r\n\r\n## 六、易错点提醒\r\n\r\n1. 栈判空检查\r\n```cpp\r\n// 错误写法\r\nif (stk.back() == ch) {  // 没有检查栈是否为空\r\n    stk.pop_back();\r\n}\r\n\r\n// 正确写法\r\nif (!stk.empty() && stk.back() == ch) {\r\n    stk.pop_back();\r\n}\r\n```\r\n\r\n2. 字符比较\r\n```cpp\r\n// 不要忘记相等时才删除\r\nif (!stk.empty() && stk.back() == ch)  // 必须完全相等\r\n```\r\n\r\n## 七、相关题目\r\n- [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)\r\n- [1209. 删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)\r\n\r\n## 八、总结\r\n\r\n这道题是栈的经典应用：\r\n1. 展示了栈在处理\"需要和前一个元素比较\"类问题时的优势\r\n2. 说明了有时候用基础数据结构（string）模拟栈会比直接使用stack更优\r\n3. 体现了在字符串处理中，\"后进先出\"的场景\r\n\r\n掌握这道题对理解栈的应用场景很有帮助，也为处理类似的字符串问题提供了思路。"}]}