{"data":[{"name":"2024-11-29 16:40:43","id":1732869643280,"body":"```thinking\r\n让我基于这个模板来详细分析一下这道柱状图最大矩形的问题...\r\n\r\n首先需要理清楚题目的核心要求和关键概念:\r\n- 输入是一个非负整数数组,表示柱状图的高度\r\n- 要求找出能够勾勒出的最大矩形面积\r\n- 关键是要理解每个柱子可以向左右扩展,直到遇到比它矮的柱子\r\n\r\n示例分析很重要:\r\n1. [2,1,5,6,2,3] 这个基本示例展示了:\r\n   - 高度为2的柱子可以扩展成2×1的矩形\r\n   - 高度为5和6的柱子可以组成5×2=10的矩形\r\n   - 最终最大面积是10\r\n\r\n2. 特殊情况:\r\n   - 单调递增/递减序列\r\n   - 所有柱子高度相同\r\n   - 只有一个柱子\r\n\r\n解题思路的核心是单调栈:\r\n1. 维护一个单调递增的栈\r\n2. 当遇到一个较小的高度时,说明之前的较高柱子到此为止\r\n3. 可以计算以之前柱子为高的矩形面积\r\n\r\n让我按照模板组织一个完整的题解...\r\n```\r\n\r\n# 84. 柱状图中最大的矩形\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 给定 n 个非负整数,表示柱状图中各柱子的高度\r\n- 每个柱子彼此相邻,宽度为 1\r\n- 求在该柱状图中能够勾勒出的矩形的最大面积\r\n\r\n### 2. 关键概念\r\n- 柱状图(Histogram): 由相邻的柱子组成,每个柱子宽度相同\r\n- 矩形面积: 高度×宽度\r\n- 单调栈: 维护一个单调递增/递减的栈结构\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：heights = [2,1,5,6,2,3]\r\n输出：10\r\n解释：\r\n1. 可以得到的矩形:\r\n   - 高度2: 2×1 = 2\r\n   - 高度1: 1×6 = 6\r\n   - 高度5: 5×2 = 10\r\n   - 高度6: 6×1 = 6\r\n   - 高度2: 2×4 = 8\r\n   - 高度3: 3×1 = 3\r\n2. 最大面积为10(高度为5,宽度为2)\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：heights = [2,4]\r\n输出：4\r\n解释：单调递增序列,最大矩形为高度2,宽度2的矩形\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n- 使用单调栈解法\r\n- 在数组两端添加高度为0的哨兵简化边界处理\r\n- 一次遍历即可得到结果\r\n\r\n### 2. 具体流程\r\n1. 数组两端添加0\r\n2. 维护单调递增栈\r\n3. 当遇到较小高度时:\r\n   - 弹出栈顶元素计算面积\r\n   - width = 当前位置 - 栈顶下一个元素位置 - 1\r\n   - height = 被弹出元素的高度\r\n4. 更新最大面积\r\n\r\n## 四、代码详解\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int largestRectangleArea(vector<int>& heights) {\r\n        // 添加哨兵\r\n        heights.insert(heights.begin(), 0);\r\n        heights.push_back(0);\r\n        \r\n        stack<int> st;\r\n        st.push(0);\r\n        int maxArea = 0;\r\n        \r\n        // 核心算法\r\n        for (int i = 1; i < heights.size(); i++) {\r\n            while (!st.empty() && heights[i] < heights[st.top()]) {\r\n                int height = heights[st.top()];\r\n                st.pop();\r\n                int width = i - st.top() - 1;\r\n                maxArea = max(maxArea, height * width);\r\n            }\r\n            st.push(i);\r\n        }\r\n        \r\n        return maxArea;\r\n    }\r\n};\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- 单调栈保证了每个柱子都能找到左右第一个比它小的元素\r\n- 哨兵的使用确保了所有柱子都能被处理\r\n- 一次遍历即可得到所有可能的矩形面积\r\n\r\n### 2. 重要细节\r\n- 栈中存储下标而不是高度\r\n- 计算宽度时要减1\r\n- 使用哨兵简化边界处理\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(n)\r\n  - 每个元素最多入栈出栈各一次\r\n- **空间复杂度**: O(n)\r\n  - 栈的空间开销\r\n\r\n## 七、常见错误\r\n\r\n1. **忘记处理边界情况**\r\n```cpp\r\n// 错误:没有添加哨兵\r\nfor (int i = 0; i < heights.size(); i++)\r\n```\r\n\r\n2. **计算宽度错误**\r\n```cpp\r\n// 错误:忘记减1\r\nint width = i - st.top();  // 应该是 i - st.top() - 1\r\n```\r\n\r\n## 八、相关题目\r\n- [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)\r\n- [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)"}]}