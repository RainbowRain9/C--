{"data":[{"name":"2024-11-22 17:13:51","id":1732266831762,"body":"\r\n# 658.找到K个最接近的元素\r\n\r\n## 题目要求\r\n给定一个**排序数组** arr，找到 k 个最接近 x 的元素。如果两个数的差值相等，优先选择较小的那个数。\r\n\r\n## 解题思路\r\n利用二分查找找到最优的长度为k的窗口起始位置：\r\n1. 因为数组已排序，所以答案一定是连续的k个数\r\n2. 通过比较x到窗口两端的距离来判断移动方向\r\n\r\n## 代码实现\r\n```cpp\r\nvector<int> findClosestElements(vector<int> &arr, int k, int x) {\r\n    int n = arr.size();\r\n    // 二分查找的范围：[0, n-k]\r\n    int left = 0, right = n - k;\r\n    \r\n    while (left < right) {\r\n        int mid = left + (right - left) / 2;\r\n        // 核心判断：比较x到窗口左右边界的距离\r\n        if (x - arr[mid] > arr[mid + k] - x) {\r\n            left = mid + 1;    // 窗口右移\r\n        } else {\r\n            right = mid;       // 窗口左移或保持\r\n        }\r\n    }\r\n    \r\n    // 构造结果\r\n    vector<int> nums;\r\n    for (int i = left; i < left + k; i++) {\r\n        nums.push_back(arr[i]);\r\n    }\r\n    return nums;\r\n}\r\n```\r\n\r\n## 关键点解析\r\n\r\n### 1. 二分查找边界\r\n- **左边界**：0\r\n- **右边界**：n-k（确保能取到k个元素）\r\n\r\n### 2. 判断条件\r\n```cpp\r\nx - arr[mid] > arr[mid + k] - x\r\n```\r\n- 左边：x到窗口左边界的距离\r\n- 右边：x到窗口右边界的距离\r\n- 如果左边距离更大，窗口右移\r\n- 如果右边距离更大或相等，窗口左移或保持\r\n\r\n### 3. 正确性证明\r\n- 如果x离左边界更远，右移窗口可能找到更优解\r\n- 如果x离右边界更远或相等，根据题目要求选择较小的数，应左移或保持\r\n\r\n## 复杂度分析\r\n- **时间复杂度**：O(log(n-k) + k)\r\n  - 二分查找：O(log(n-k))\r\n  - 构造结果：O(k)\r\n- **空间复杂度**：O(1)（不计结果数组）\r\n\r\n## 注意事项\r\n1. 数组必须是已排序的\r\n2. 当差值相等时要选择较小的数\r\n3. 返回的结果也必须是有序的\r\n\r\n```thinking\r\n让我来分析这个具体例子，看看代码是如何一步步执行的...\r\n\r\n初始条件：\r\n- arr = [1,2,3,4,5]\r\n- k = 4\r\n- x = 3\r\n- n = 5\r\n\r\n二分查找过程：\r\n1. left = 0, right = n-k = 1\r\n2. 第一次迭代:\r\n   mid = 0\r\n   比较 x-arr[0] 和 arr[4]-x\r\n   3-1 = 2 vs 5-3 = 2\r\n   相等时取较小的，right = 0\r\n\r\n所以最终 left = 0，选择arr[0:4]即[1,2,3,4]\r\n\r\n这个例子很好地展示了:\r\n1. 二分查找的边界设置\r\n2. 相等情况下如何选择\r\n3. 为什么结果是正确的\r\n\r\n让我用图解方式来说明...\r\n```\r\n\r\n## 示例分析：arr = [1,2,3,4,5], k = 4, x = 3\r\n\r\n### 执行过程\r\n\r\n#### 初始条件\r\n- 数组：`[1,2,3,4,5]`\r\n- 目标值 x = 3\r\n- 需要找 k = 4 个数\r\n- 数组长度 n = 5\r\n\r\n#### 二分查找过程\r\n\r\n1. **初始化**\r\n   ```\r\n   left = 0\r\n   right = n-k = 1\r\n   ```\r\n\r\n2. **第一次迭代**\r\n   ```\r\n   mid = 0\r\n   比较：\r\n   x - arr[mid] = 3-1 = 2\r\n   arr[mid+k] - x = 5-3 = 2\r\n   ```\r\n\r\n3. **判断条件**\r\n   - `2 ≤ 2`，所以 `right = mid = 0`\r\n   - 循环结束，`left = 0`\r\n\r\n#### 结果构造\r\n```cpp\r\n从 arr[left] 开始取 k 个元素：\r\n[1,2,3,4]\r\n```\r\n\r\n### 为什么这是正确答案？\r\n\r\n1. **窗口位置**\r\n   - 窗口从索引0开始\r\n   - 包含元素 [1,2,3,4]\r\n   - 这确实是距离3最近的4个数\r\n\r\n2. **验证最优性**\r\n   - 1到3的距离是2\r\n   - 2到3的距离是1\r\n   - 3到3的距离是0\r\n   - 4到3的距离是1\r\n   - 5到3的距离是2\r\n\r\n3. **其他可能的窗口**\r\n   - [2,3,4,5] 不是更优解，因为当距离相等时优先选择较小的数\r\n\r\n### 图解\r\n```\r\n数组:  1  2  3  4  5\r\n距离:  2  1  0  1  2\r\n          ↑\r\n         x=3\r\n窗口: [      k=4     ]\r\n```\r\n\r\n这个示例很好地展示了算法的核心思想：通过二分查找找到最优窗口的起始位置，当遇到相等的情况时选择较小的数。"}]}