{"data":[{"name":"2024-11-19 11:24:31","id":1731986671442,"body":"让我详细讲解这道题的解题思路和代码实现。\r\n\r\n### 1. 题目理解\r\n- 给定一个数组和操作次数k\r\n- 每次操作可以将任意一个数字+1\r\n- 目标是通过最多k次操作，使得数组中出现次数最多的数字的频次最大\r\n\r\n### 2. 解题思路\r\n1. **为什么要排序？**\r\n   - 排序后，相近的数字会挨在一起\r\n   - 如果要使某些数字相等，显然让它们变成其中最大的数字最划算\r\n   - 例如：[1,2,4] → 要使它们都变成4，比变成其他任何数字所需操作次数都少\r\n\r\n2. **滑动窗口的思想**\r\n   - 窗口内的所有数字都要变成窗口右端点的数字\r\n   - 右指针向右移动时，窗口变大，需要更多操作次数\r\n   - 当操作次数超过k时，左指针右移缩小窗口\r\n\r\n3. **如何计算操作次数？**\r\n   - 当右指针移动到新位置时，窗口内所有数字都要增加到新的右端点值\r\n   - 例如：[1,2,4] → 当右指针指向4时\r\n     - 1需要增加3次才能变成4\r\n     - 2需要增加2次才能变成4\r\n     - total = 3 + 2 = 5\r\n\r\n### 3. 代码详解\r\n```cpp:算法训练/LeetCode/All/1838-最高频元素的频数.cpp\r\nclass Solution {\r\npublic:\r\n    int maxFrequency(vector<int>& nums, int k) {\r\n        int n = nums.size();\r\n        // 1. 排序是算法的基础\r\n        sort(nums.begin(), nums.end());\r\n        \r\n        // 2. 初始化变量\r\n        long long total = 0;  // 记录当前窗口内需要的操作次数\r\n        int left = 0;        // 窗口左边界\r\n        int ans = 1;         // 最大频数（至少为1）\r\n        \r\n        // 3. 滑动窗口\r\n        for (int right = 1; right < n; right++) {\r\n            // 4. 计算新增的操作次数\r\n            // nums[right] - nums[right-1]：每个数字需要增加的量\r\n            // (right - left)：需要增加的数字个数\r\n            total += (long long)(nums[right] - nums[right - 1]) * (right - left);\r\n            \r\n            // 5. 当操作次数超过k时，缩小窗口\r\n            while (total > k) {\r\n                // 减去左边界数字所需的操作次数\r\n                total -= nums[right] - nums[left];\r\n                left++;\r\n            }\r\n            \r\n            // 6. 更新答案\r\n            ans = max(ans, right - left + 1);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 4. 举例说明\r\n以示例 `nums = [1,2,4], k = 5` 为例：\r\n\r\n1. 排序后数组保持不变 `[1,2,4]`\r\n2. 遍历过程：\r\n   ```\r\n   右指针=1：\r\n   - 窗口：[1,2]\r\n   - total = (2-1)*1 = 1\r\n   - 当前最大频数 = 2\r\n   \r\n   右指针=2：\r\n   - 窗口：[1,2,4]\r\n   - total = 1 + (4-2)*2 = 5\r\n   - 当前最大频数 = 3\r\n   ```\r\n\r\n### 5. 复杂度分析\r\n- 时间复杂度：O(nlogn)\r\n  - 排序需要 O(nlogn)\r\n  - 滑动窗口需要 O(n)\r\n- 空间复杂度：O(1)\r\n  - 只使用了常数额外空间\r\n\r\n### 6. 注意事项\r\n1. 使用 `long long` 避免整数溢出\r\n2. 初始化 `ans = 1`，因为最少也有一个数字\r\n3. 右指针从1开始，因为单个元素不需要任何操作\r\n\r\n这种解法的优雅之处在于它巧妙地利用了排序后数组的特性，通过滑动窗口高效地找到了最优解。"}]}