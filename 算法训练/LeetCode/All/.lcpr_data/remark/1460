{"data":[{"name":"2024-11-18 20:14:21","id":1731932061734,"body":"我来详细讲解这道题的解决方案。这是一个典型的滑动窗口问题，代码实现非常优雅。\r\n\r\n### 核心思路\r\n\r\n1. **滑动窗口的使用**：\r\n   - 使用左指针`left`和右指针`right`维护一个窗口\r\n   - 用数组`cnt`记录窗口内a、b、c三个字符的出现次数\r\n\r\n2. **计数逻辑**：\r\n   - 当找到一个包含所有三种字符的窗口时，以right为右端点的所有子串都是合法的\r\n   - 合法子串的数量为`n - right`（n为字符串长度）\r\n\r\n3. **关键代码分析**：\r\n```cpp:算法训练/LeetCode/All/1358-包含所有三种字符的子字符串数目.cpp\r\nclass Solution {\r\npublic:\r\n    int numberOfSubstrings(string s) {\r\n        int n = s.length();\r\n        int cnt[3] = {0};  // 记录a,b,c的出现次数\r\n        int left = 0, ans = 0;\r\n        \r\n        for (int right = 0; right < n; right++) {\r\n            cnt[s[right] - 'a']++;  // 将右边界字符加入窗口\r\n            \r\n            // 当窗口包含所有三种字符时\r\n            while (cnt[0] && cnt[1] && cnt[2]) {\r\n                ans += n - right;    // 关键：计算以right为右端点的所有合法子串数量\r\n                cnt[s[left] - 'a']--; // 缩小窗口\r\n                left++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 详细解释\r\n\r\n1. **为什么是 `ans += n - right`？**\r\n   - 假设当前找到一个合法窗口[left, right]\r\n   - 那么以right为右端点的所有子串[i, right]（其中i从0到left）都是合法的\r\n   - 因为如果[left, right]包含所有字符，那么[i, right]（i < left）必然也包含所有字符\r\n   - 合法子串的数量就是从当前位置right到字符串末尾的距离：n - right\r\n\r\n2. **时间复杂度**：\r\n   - 虽然有两层循环，但left和right都是单向移动的\r\n   - 每个位置最多被访问两次（一次作为right，一次作为left）\r\n   - 因此总时间复杂度为O(n)\r\n\r\n3. **空间复杂度**：\r\n   - 只使用了固定大小的数组cnt和几个整型变量\r\n   - 空间复杂度为O(1)\r\n\r\n这个解法的巧妙之处在于它不需要真正地枚举所有子串，而是通过滑动窗口的性质来快速计算合法子串的数量。"}]}