{"data":[{"name":"2024-12-18 11:02:29","id":1734490949450,"body":"让我按照这个模板来详细分析这道题。\r\n\r\n# 34. 在排序数组中查找元素的第一个和最后一个位置\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 在一个按升序排列的整数数组中找到目标值的第一个和最后一个位置\r\n- 如果目标值不存在，返回 [-1, -1]\r\n- 要求时间复杂度为 O(log n)\r\n\r\n### 2. 关键概念\r\n- 排序数组：数组元素按升序排列\r\n- 二分查找：满足时间复杂度要求的关键算法\r\n- 边界查找：需要找到目标值的起始和结束位置\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：nums = [5,7,7,8,8,10], target = 8\r\n输出：[3,4]\r\n解释：\r\n1. 8在数组中首次出现的位置是索引3\r\n2. 8在数组中最后出现的位置是索引4\r\n3. 返回[3,4]\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：nums = [5,7,7,8,8,10], target = 6\r\n输出：[-1,-1]\r\n解释：6不存在于数组中，返回[-1,-1]\r\n```\r\n\r\n### 3. 边界情况\r\n```\r\n输入：nums = [], target = 0\r\n输出：[-1,-1]\r\n解释：空数组，直接返回[-1,-1]\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n- 使用二分查找的变体：lower_bound\r\n- 通过两次二分查找分别确定起始和结束位置\r\n- 利用排序数组的特性优化查找过程\r\n\r\n### 2. 具体流程\r\n1. 实现lower_bound函数找到第一个大于等于目标值的位置\r\n2. 用lower_bound找到target的起始位置\r\n3. 用lower_bound找到target+1的位置，减1得到结束位置\r\n4. 处理特殊情况（目标值不存在、数组为空等）\r\n\r\n## 四、代码详解\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    // 查找第一个大于等于target的位置\r\n    int lower_bound(vector<int>& nums, int target) {\r\n        if(nums.empty()) return 0;\r\n        \r\n        int left = 0;\r\n        int right = nums.size() - 1;\r\n        \r\n        while(left <= right) {\r\n            int mid = left + (right - left) / 2;\r\n            if(nums[mid] < target) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n    \r\n    vector<int> searchRange(vector<int>& nums, int target) {\r\n        // 找到第一个位置\r\n        int start = lower_bound(nums, target);\r\n        \r\n        // 处理目标值不存在的情况\r\n        if(start == nums.size() || nums[start] != target) {\r\n            return {-1, -1};\r\n        }\r\n        \r\n        // 找到最后一个位置\r\n        int end = lower_bound(nums, target + 1) - 1;\r\n        \r\n        return {start, end};\r\n    }\r\n};\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- lower_bound保证找到第一个大于等于目标值的位置\r\n- 通过查找target+1的位置再减1，可以得到target的最后位置\r\n- 特殊情况的处理确保了算法的完整性\r\n\r\n### 2. 重要细节\r\n- 二分查找的边界条件（left <= right）\r\n- 中点计算避免溢出（left + (right - left) / 2）\r\n- 返回值的处理（left作为插入位置）\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(log n)\r\n  - 两次二分查找，每次O(log n)\r\n- **空间复杂度**: O(1)\r\n  - 只使用了常数额外空间\r\n\r\n## 七、常见错误\r\n\r\n1. **边界条件处理不当**\r\n```cpp\r\n// 错误：没有处理数组为空的情况\r\nint lower_bound(vector<int>& nums, int target) {\r\n    int left = 0, right = nums.size();\r\n    // ...\r\n}\r\n```\r\n\r\n2. **二分查找实现错误**\r\n```cpp\r\n// 错误：中点计算可能溢出\r\nint mid = (left + right) / 2;\r\n```\r\n\r\n## 八、相关题目\r\n- [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\r\n- [278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)\r\n\r\n这道题是二分查找的经典应用，通过两次二分查找巧妙地解决了在排序数组中查找元素范围的问题。关键在于正确实现lower_bound函数并处理好各种边界情况。\r\n"}]}