{"data":[{"name":"2024-11-23 16:30:37","id":1732350637681,"body":"```thinking\r\n让我深入思考一下这道题的本质和解法...\r\n\r\n首先，这是一道经典的双指针题目，但理解起来并不容易。我需要从以下几个方面详细讲解：\r\n\r\n1. 为什么这个问题可以用双指针解决？\r\n- 关键在于每个位置能接的雨水量只取决于它左右两侧的最大高度中的较小值\r\n- 双指针可以保证我们总是处理\"确定\"能接多少水的位置\r\n\r\n2. 算法的正确性：\r\n- 当pre_max < suf_max时，左边的柱子能接的水量就已经确定了\r\n- 因为就算右边还有更高的柱子，也不会影响左边能接的水量\r\n- 同理对右边的情况\r\n\r\n3. 需要举一些具体的例子来说明：\r\n[0,1,0,2,1,0,1,3,2,1,2,1]\r\n- 可以一步步模拟双指针的移动\r\n- 展示每一步是如何计算当前位置的水量的\r\n\r\n4. 还要提到其他解法：\r\n- 暴力解法：对每个位置找左右最大值\r\n- 动态规划：预处理左右最大值数组\r\n- 单调栈解法：维护一个单调递减栈\r\n\r\n这道题的精妙之处在于如何用O(1)空间解决看似需要预处理的问题。\r\n```\r\n\r\n# 42. 接雨水 - 详细题解\r\n\r\n## 一、问题本质\r\n\r\n要理解这道题，我们需要先明确几个关键点：\r\n\r\n1. **如何确定某个位置能接多少雨水？**\r\n   - 该位置能接的雨水量 = min(左边最高柱子, 右边最高柱子) - 当前位置高度\r\n   - 如果计算结果为负数，则该位置不能接雨水\r\n\r\n2. **为什么传统方法效率不高？**\r\n   - 暴力法需要对每个位置都向两边扫描\r\n   - 会有大量重复计算\r\n\r\n## 二、图解双指针\r\n\r\n让我们通过一个例子详细说明双指针的工作过程：\r\n\r\n```\r\n初始状态：\r\n     |\r\n3    |                     █\r\n2    |         █  ~ ~ ~ ~ █ █ ~ █\r\n1    |   █  ~ █ █ ~ █  ~ █ █ █ █\r\n0    | █ █ █ █ █ █ █ █ █ █ █ █\r\n      0 1 0 2 1 0 1 3 2 1 2 1\r\n      ↑                       ↑\r\n     left                   right\r\n```\r\n\r\n### 关键步骤说明：\r\n\r\n1. **初始化**：\r\n   - left = 0, right = n-1\r\n   - pre_max = 0, suf_max = 0\r\n\r\n2. **移动规则**：\r\n   - 如果 pre_max < suf_max，移动 left\r\n   - 否则移动 right\r\n   - 每次移动都更新对应的最大值\r\n\r\n3. **计算水量**：\r\n   - 当前位置能接的水 = min(pre_max, suf_max) - height[当前位置]\r\n\r\n## 三、代码详解\r\n\r\n让我们逐段分析代码的实现：\r\n\r\n```cpp:算法训练/LeetCode/All/42-接雨水.cpp\r\nclass Solution {\r\npublic:\r\n    int trap(vector<int>& height) {\r\n        int n = height.size();\r\n        int ans = 0;\r\n        // 维护两个最大值\r\n        int pre_max = 0, suf_max = 0;\r\n        // 双指针\r\n        int left = 0, right = n - 1;\r\n        \r\n        while (left <= right) {\r\n            // 更新最大值\r\n            pre_max = max(pre_max, height[left]);    // 左边的最大值\r\n            suf_max = max(suf_max, height[right]);   // 右边的最大值\r\n            \r\n            if (pre_max < suf_max) {\r\n                // 左边较小，处理左边\r\n                ans += pre_max - height[left++];\r\n            } else {\r\n                // 右边较小或相等，处理右边\r\n                ans += suf_max - height[right--];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 代码要点解释：\r\n\r\n1. **为什么不用担心减出负数？**\r\n   - pre_max 和 suf_max 总是包含当前处理的位置\r\n   - 所以 pre_max >= height[left] 始终成立\r\n   - 同理 suf_max >= height[right] 也始终成立\r\n\r\n2. **为什么移动较小的一边是安全的？**\r\n   - 假设 pre_max < suf_max\r\n   - 则左边能接的水量已经确定\r\n   - 即使右边还有更高的柱子，也不会影响左边的结果\r\n\r\n## 四、其他解法对比\r\n\r\n### 1. 暴力解法\r\n```cpp\r\nint trap(vector<int>& height) {\r\n    int ans = 0;\r\n    int n = height.size();\r\n    for (int i = 1; i < n - 1; i++) {\r\n        int left_max = 0, right_max = 0;\r\n        // 找左边最高\r\n        for (int j = 0; j <= i; j++) {\r\n            left_max = max(left_max, height[j]);\r\n        }\r\n        // 找右边最高\r\n        for (int j = i; j < n; j++) {\r\n            right_max = max(right_max, height[j]);\r\n        }\r\n        // 计算当前位置能接的水\r\n        ans += min(left_max, right_max) - height[i];\r\n    }\r\n    return ans;\r\n}\r\n```\r\n- 时间复杂度：O(n²)\r\n- 空间复杂度：O(1)\r\n\r\n### 2. 动态规划解法\r\n```cpp\r\nint trap(vector<int>& height) {\r\n    int n = height.size();\r\n    vector<int> left_max(n), right_max(n);\r\n    \r\n    // 预处理左边最大值\r\n    left_max[0] = height[0];\r\n    for (int i = 1; i < n; i++) {\r\n        left_max[i] = max(left_max[i-1], height[i]);\r\n    }\r\n    \r\n    // 预处理右边最大值\r\n    right_max[n-1] = height[n-1];\r\n    for (int i = n-2; i >= 0; i--) {\r\n        right_max[i] = max(right_max[i+1], height[i]);\r\n    }\r\n    \r\n    // 计算结果\r\n    int ans = 0;\r\n    for (int i = 0; i < n; i++) {\r\n        ans += min(left_max[i], right_max[i]) - height[i];\r\n    }\r\n    return ans;\r\n}\r\n```\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n## 五、复杂度分析\r\n\r\n### 双指针解法：\r\n- **时间复杂度**：O(n)\r\n  - 只需要遍历一次数组\r\n  - 每个位置最多被访问一次\r\n  \r\n- **空间复杂度**：O(1)\r\n  - 只使用了常数个变量\r\n  - 不需要额外的数组空间\r\n\r\n## 六、易错点提醒\r\n\r\n1. **循环条件**\r\n   - 使用 `left <= right` 而不是 `left < right`\r\n   - 因为中间位置也需要处理\r\n\r\n2. **最大值更新时机**\r\n   - 必须在处理当前位置之前更新最大值\r\n   - 否则可能会计算错误\r\n\r\n3. **边界情况**\r\n   - 数组长度小于3时无法接水\r\n   - 但代码自然就处理了这种情况\r\n\r\n## 七、相关题目推荐\r\n\r\n1. [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)\r\n   - 同样使用双指针\r\n   - 但计算逻辑不同\r\n\r\n2. [407. 接雨水 II](https://leetcode.cn/problems/trapping-rain-water-ii/)\r\n   - 二维版本\r\n   - 需要使用优先队列"}]}