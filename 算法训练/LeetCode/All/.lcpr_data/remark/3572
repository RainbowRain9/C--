{"data":[{"name":"2024-11-19 21:13:29","id":1732022009756,"body":"\r\n\r\n# LeetCode 3298 - 统计重新排列后包含另一个字符串的子字符串数目 II\r\n\r\n```thinking\r\n让我深入分析这道题...\r\n\r\n首先理解题目要求：\r\n1. 需要找到word1中所有可以重排得到word2的子串数量\r\n2. 子串必须是连续的\r\n3. 重排后得到的word2必须完全匹配，不能多也不能少\r\n\r\n关键点分析：\r\n- 这是一个字符串匹配问题，但关注的是字符出现的频次而不是顺序\r\n- 可以用滑动窗口来维护一个候选区间\r\n- 需要统计字符频次来判断是否可以重排得到word2\r\n\r\n解题思路：\r\n1. 先统计word2中每个字符的频次\r\n2. 用滑动窗口在word1上移动，维护当前窗口中缺少的字符种类数\r\n3. 当窗口满足条件时，收缩左边界并统计结果\r\n\r\n数据结构选择：\r\n- 使用数组而不是map来统计频次，因为只有小写字母\r\n- 用less变量记录还缺少的字符种类数，避免每次都要检查整个频次数组\r\n\r\n关于复杂度：\r\n- 时间复杂度应该是O(n)，其中n是word1的长度\r\n- 空间复杂度是O(1)，因为字符集大小固定为26\r\n\r\n让我再检查一下边界情况：\r\n- word1比word2短时直接返回0\r\n- 需要用long long因为结果可能很大\r\n- 重复的子串只计数一次，这个在当前解法中自然满足\r\n\r\n这个思路应该是完整的，让我整理一下详细的解释。\r\n```\r\n\r\n## 题目描述\r\n给你两个字符串 `word1` 和 `word2`。如果一个字符串能通过重新排列字符串中的字符得到另一个字符串，我们称这两个字符串**可互相转换**。请你统计有多少 `word1` 的非空子字符串可以通过重新排列字符得到 `word2`。\r\n\r\n## 示例分析\r\n### 示例 1\r\n```\r\n输入：word1 = \"bcca\", word2 = \"abc\"\r\n输出：1\r\n解释：word1 中只有子字符串 \"bcc\" 可以通过重新排列得到 word2。\r\n```\r\n\r\n### 示例 2\r\n```\r\n输入：word1 = \"abcabc\", word2 = \"abc\"\r\n输出：4\r\n解释：以下子字符串可以通过重新排列得到 word2：\r\n- \"abc\" 从下标 0 开始\r\n- \"cba\" 从下标 1 开始\r\n- \"cab\" 从下标 2 开始\r\n- \"abc\" 从下标 3 开始\r\n```\r\n\r\n## 详细解题思路\r\n### 1. 核心思想\r\n使用滑动窗口配合字符频次统计：\r\n1. 维护一个频次数组，记录还需要多少个每种字符\r\n2. 使用一个变量 less 记录还缺少的字符种类数\r\n3. 当 less 为 0 时，表示当前窗口包含了所有需要的字符\r\n\r\n### 2. 算法流程\r\n1. 初始化：\r\n   - 统计 word2 中每个字符的频次\r\n   - 计算 word2 中不同字符的数量（less）\r\n   - 如果 word1 长度小于 word2，直接返回 0\r\n\r\n2. 滑动窗口：\r\n   - 右指针不断向右扩展，更新频次和 less\r\n   - 当 less 为 0 时，说明找到一个有效窗口\r\n   - 收缩左边界直到窗口不再满足条件\r\n   - 统计满足条件的子串数量\r\n\r\n### 3. 代码实现\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    long long validSubstringCount(string word1, string word2) {\r\n        // 特判：如果word1比word2短，直接返回0\r\n        if (word1.length() < word2.length()) {\r\n            return 0;\r\n        }\r\n        \r\n        // 统计word2中字符频次\r\n        int cnt[26]{};  // 初始化频次数组\r\n        for (char b : word2) {\r\n            cnt[b - 'a']++;\r\n        }\r\n        \r\n        // 计算word2中不同字符的数量\r\n        int less = 0;\r\n        for (int c : cnt) {\r\n            if (c > 0) {\r\n                less++;\r\n            }\r\n        }\r\n        \r\n        // 滑动窗口处理\r\n        long long ans = 0;\r\n        int left = 0;\r\n        for (char b : word1) {\r\n            // 加入新字符\r\n            cnt[b - 'a']--;\r\n            if (cnt[b - 'a'] == 0) {\r\n                less--;  // 一个字符的需求被满足\r\n            }\r\n            \r\n            // 当窗口满足条件时，收缩左边界\r\n            while (less == 0) {\r\n                char out = word1[left++];\r\n                if (cnt[out - 'a'] == 0) {\r\n                    less++;  // 移除字符后不再满足需求\r\n                }\r\n                cnt[out - 'a']++;\r\n            }\r\n            \r\n            // 统计结果\r\n            ans += left;\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 4. 代码详解\r\n1. **频次统计**：\r\n   ```cpp\r\n   int cnt[26]{};  // 使用数组统计频次\r\n   for (char b : word2) {\r\n       cnt[b - 'a']++;\r\n   }\r\n   ```\r\n   - 使用大小为 26 的数组记录每个字符的需求量\r\n   - 下标通过 `b - 'a'` 计算\r\n\r\n2. **字符种类计数**：\r\n   ```cpp\r\n   int less = 0;\r\n   for (int c : cnt) {\r\n       if (c > 0) {\r\n           less++;\r\n       }\r\n   }\r\n   ```\r\n   - less 记录还需要多少种不同的字符\r\n   - 只有频次大于 0 的字符才计数\r\n\r\n3. **窗口维护**：\r\n   ```cpp\r\n   cnt[b - 'a']--;\r\n   if (cnt[b - 'a'] == 0) {\r\n       less--;\r\n   }\r\n   ```\r\n   - 当加入字符后，如果某个字符的需求量变为 0\r\n   - 说明这个字符已经满足需求，less 减 1\r\n\r\n4. **左边界收缩**：\r\n   ```cpp\r\n   while (less == 0) {\r\n       char out = word1[left++];\r\n       if (cnt[out - 'a'] == 0) {\r\n           less++;\r\n       }\r\n       cnt[out - 'a']++;\r\n   }\r\n   ```\r\n   - 当所有字符都满足需求时，尝试收缩左边界\r\n   - 如果移除的字符导致需求不再满足，less 加 1\r\n\r\n5. **结果统计**：\r\n   ```cpp\r\n   ans += left;\r\n   ```\r\n   - left 表示当前有多少个位置可以作为子串的起点\r\n   - 累加到最终结果中\r\n\r\n## 复杂度分析\r\n- **时间复杂度**：O(n)\r\n  - n 是 word1 的长度\r\n  - 每个字符最多被访问两次（加入和移除）\r\n\r\n- **空间复杂度**：O(1)\r\n  - 只使用了固定大小的数组和变量\r\n\r\n## 优化建议\r\n1. 可以在开始时就检查 word2 中的字符是否都在 word1 中出现\r\n2. 如果 word2 中有重复字符，可以预处理得到实际需要的不同字符数\r\n3. 可以使用位运算优化字符集的判断\r\n\r\n## 注意事项\r\n1. 使用 long long 类型避免整数溢出\r\n2. 注意左边界收缩的条件判断\r\n3. 字符到下标的转换要正确\r\n4. 频次统计的增减要配对\r\n\r\n## 相关题目\r\n1. LeetCode 567 - 字符串的排列\r\n2. LeetCode 438 - 找到字符串中所有字母异位词\r\n3. LeetCode 76 - 最小覆盖子串"}]}