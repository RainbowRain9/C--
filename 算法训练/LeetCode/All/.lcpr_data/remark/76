{"data":[{"name":"2024-11-15 21:05:59","id":1731675959067,"body":"哈希表\r\nclass Solution\r\n{\r\npublic:\r\n    string minWindow(string s, string t)\r\n    {\r\n        // 使用哈希表记录需要的字符及其个数\r\n        unordered_map<char, int> need, window;\r\n        for (char c : t)\r\n        {\r\n            need[c]++;\r\n        }\r\n\r\n        int left = 0, right = 0;\r\n        int valid = 0; // 记录已经满足要求的字符个数\r\n        int start = 0, len = INT_MAX;\r\n\r\n        while (right < s.size())\r\n        {\r\n            // 扩大窗口\r\n            char c = s[right];\r\n            right++;\r\n            \r\n            // 更新窗口内字符计数\r\n            if (need.count(c))\r\n            {\r\n                window[c]++;\r\n                if (window[c] == need[c])\r\n                {\r\n                    valid++; // 该字符满足要求\r\n                }\r\n            }\r\n\r\n            // 当所有字符都满足要求时,尝试缩小窗口\r\n            while (valid == need.size())\r\n            {\r\n                // 更新最小覆盖子串\r\n                if (right - left < len)\r\n                {\r\n                    start = left;\r\n                    len = right - left;\r\n                }\r\n\r\n                // 缩小窗口\r\n                char d = s[left];\r\n                left++;\r\n                \r\n                // 更新窗口内字符计数\r\n                if (need.count(d))\r\n                {\r\n                    if (window[d] == need[d])\r\n                    {\r\n                        valid--; // 该字符不再满足要求\r\n                    }\r\n                    window[d]--;\r\n                }\r\n            }\r\n        }\r\n\r\n        return len == INT_MAX ? \"\" : s.substr(start, len);\r\n    }\r\n};"},{"name":"2024-11-15 21:06:44","id":1731676004754,"body":"数组\r\nclass Solution {\r\npublic:\r\n    string minWindow(string s, string t) {\r\n        int m = s.length();\r\n        int ans_left = -1, ans_right = m;\r\n        int cnt[128]{};\r\n        int less = 0;\r\n        for (char c : t) {\r\n            if (cnt[c] == 0) {\r\n                less++; // 有 less 种字母的出现次数 < t 中的字母出现次数\r\n            }\r\n            cnt[c]++;\r\n        }\r\n\r\n        int left = 0;\r\n        for (int right = 0; right < m; right++) {\r\n            char c = s[right]; // 右端点字母\r\n            cnt[c]--;          // 右端点字母移入子串\r\n            if (cnt[c] == 0) {\r\n                less--; // 原来窗口内 c 的出现次数比 t 的少，现在一样多\r\n            }\r\n            while (less == 0) { // 涵盖：所有字母的出现次数都是 >=\r\n                if (right - left < ans_right - ans_left) {\r\n                    ans_left = left; // 记录此时的左右端点\r\n                    ans_right = right;\r\n                }\r\n                char x = s[left]; // 左端点字母\r\n                if (cnt[x] == 0) {\r\n                    less++; // x移出窗口后，窗口内x的出现次数比t的少\r\n                }\r\n                cnt[x]++; // 左端点字母移出子串\r\n                left++;\r\n            }\r\n        }\r\n        return ans_left < 0 ? \"\" : s.substr(ans_left, ans_right - ans_left + 1);\r\n    }\r\n};"}]}