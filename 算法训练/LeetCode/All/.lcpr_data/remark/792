{"data":[{"name":"2024-12-18 11:29:05","id":1734492545325,"body":"```thinking\r\n看到这个通用题解模板，让我思考如何针对二分查找这道题进行系统化的讲解...\r\n\r\n这是一道非常经典的算法题，非常适合用来详细讲解二分查找的核心概念和实现细节。\r\n\r\n我需要重点关注以下几个方面:\r\n1. 二分查找的基本原理和适用条件\r\n2. 不同的区间定义方式([left, right]和[left, right))对实现的影响\r\n3. 中间位置的计算方式及其溢出风险\r\n4. 边界条件的处理\r\n5. 循环不变量的维护\r\n\r\n示例分析方面:\r\n- 需要包含常规查找成功的case\r\n- 需要展示查找失败的情况\r\n- 需要考虑数组长度为1的边界case\r\n- 最好能用图解展示指针移动过程\r\n\r\n代码实现上:\r\n- 要突出标准的三分支写法(等于/大于/小于)\r\n- 说明left + (right-left)/2 相比 (left+right)/2的优势\r\n- 强调循环条件 left <= right 的重要性\r\n\r\n复杂度分析:\r\n- 时间复杂度O(log n)的推导\r\n- 为什么是对数级别的复杂度\r\n\r\n我觉得应该按照模板结构来写一个完整的题解，让读者能够全面理解二分查找算法。\r\n```\r\n\r\n让我按照模板为这道题写一个详细的题解:\r\n\r\n# 704. 二分查找\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 给定一个 **升序排列** 的整数数组 `nums` 和一个目标值 `target`\r\n- 在数组中找到 `target`，返回其下标\r\n- 如果目标值不存在，返回 `-1`\r\n- 要求时间复杂度为 O(log n)\r\n\r\n### 2. 关键概念\r\n- 二分查找的前提是数组必须有序\r\n- 通过比较中间元素来缩小查找范围\r\n- 需要正确处理区间边界\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：nums = [-1,0,3,5,9,12], target = 9\r\n输出：4\r\n解释：\r\n1. 初始区间 [0,5]，mid = 2，nums[2] = 3 < 9，左指针移到 mid+1\r\n2. 新区间 [3,5]，mid = 4，nums[4] = 9 = target\r\n3. 返回下标 4\r\n```\r\n\r\n### 2. 查找失败示例\r\n```\r\n输入：nums = [-1,0,3,5,9,12], target = 2\r\n输出：-1\r\n解释：\r\n1. 初始区间 [0,5]，mid = 2，nums[2] = 3 > 2，右指针移到 mid-1\r\n2. 新区间 [0,1]，mid = 0，nums[0] = -1 < 2，左指针移到 mid+1\r\n3. 新区间 [1,1]，mid = 1，nums[1] = 0 < 2，左指针移到 mid+1\r\n4. left > right，循环结束，返回 -1\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n- 维护查找区间 [left, right]\r\n- 每次取中间位置 mid 比较\r\n- 根据比较结果缩小区间范围\r\n- 直到找到目标值或区间为空\r\n\r\n### 2. 具体流程\r\n1. 初始化左右指针\r\n2. 循环条件为 left <= right\r\n3. 计算中间位置\r\n4. 三种情况的处理：\r\n   - 等于目标值：直接返回\r\n   - 大于目标值：右指针左移\r\n   - 小于目标值：左指针右移\r\n\r\n## 四、代码详解\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int search(vector<int>& nums, int target) {\r\n        // 初始化左右边界\r\n        int left = 0, right = nums.size() - 1;\r\n        \r\n        // 区间不为空时继续查找\r\n        while (left <= right) {\r\n            // 计算中间位置，防止溢出\r\n            int mid = left + (right - left) / 2;\r\n            \r\n            // 找到目标值\r\n            if (nums[mid] == target) {\r\n                return mid;\r\n            }\r\n            // 中间值大于目标值，查找左半部分\r\n            else if (nums[mid] > target) {\r\n                right = mid - 1;\r\n            }\r\n            // 中间值小于目标值，查找右半部分\r\n            else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        \r\n        // 未找到目标值\r\n        return -1;\r\n    }\r\n};\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- 循环不变量：target 始终在 [left, right] 区间内\r\n- 区间每次都会缩小\r\n- 区间为空时说明未找到目标值\r\n\r\n### 2. 重要细节\r\n- 使用 left + (right - left) / 2 避免整数溢出\r\n- 循环条件包含 等于 的情况\r\n- 区间收缩时不包含 mid\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(log n)\r\n  - 每次操作将查找范围缩小一半\r\n  - 最多需要 log₂n 次查找\r\n- **空间复杂度**: O(1)\r\n  - 只使用常数额外空间\r\n\r\n## 七、常见错误\r\n\r\n1. **整数溢出**\r\n```cpp\r\n// 错误写法\r\nint mid = (left + right) / 2;  // 可能溢出\r\n\r\n// 正确写法\r\nint mid = left + (right - left) / 2;\r\n```\r\n\r\n2. **死循环**\r\n```cpp\r\n// 错误写法\r\nright = mid;  // 可能导致死循环\r\n\r\n// 正确写法\r\nright = mid - 1;\r\n```\r\n\r\n## 八、相关题目\r\n- [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\r\n- [278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)\r\n- [69. x 的平方根](https://leetcode.cn/problems/sqrtx/)\r\n\r\n---\r\n\r\n这个题解涵盖了二分查找的核心概念和实现细节，希望对你理解这个经典算法有所帮助。如果有任何疑问，欢迎继续提问。\r\n"}]}