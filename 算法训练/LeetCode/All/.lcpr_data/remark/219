{"data":[{"name":"2024-11-20 15:19:26","id":1732087166730,"body":"```thinking\r\n让我仔细分析一下这道题和代码的实现...\r\n\r\n首先理解题目要求:\r\n- 给定一个整数数组nums和一个整数k\r\n- 需要判断是否存在两个不同下标i和j,满足nums[i] == nums[j]且abs(i-j) <= k\r\n- 也就是说要找相同的数字,且它们的下标差不超过k\r\n\r\n看看代码实现的思路:\r\n1. 使用滑动窗口 + 哈希集合的方法\r\n2. 维护一个大小为k的窗口,用unordered_set存储窗口内的数字\r\n3. 右指针right不断向右移动:\r\n   - 如果right > k,需要移除窗口最左边的元素(right-k-1位置)\r\n   - 检查当前数字是否在集合中,在则找到答案\r\n   - 将当前数字加入集合\r\n4. 时间复杂度O(n),空间复杂度O(k)\r\n\r\n这个实现非常巧妙,我来详细解释下原理和细节...\r\n```\r\n\r\n这道题是LeetCode 219题 \"存在重复元素 II\"。让我详细讲解下代码的实现思路：\r\n\r\n1. **算法思路**\r\n- 使用滑动窗口 + 哈希集合的方法\r\n- 维护一个最大长度为k+1的窗口,用哈希集合存储窗口内的元素\r\n- 如果在添加新元素前,该元素已经在集合中,说明找到了符合条件的重复元素\r\n\r\n2. **代码详解**\r\n```cpp:算法训练/LeetCode/All/219-存在重复元素 II.cpp\r\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\r\n    unordered_set<int> s;  // 哈希集合存储窗口内的数字\r\n    int n = nums.size();\r\n    for (int right = 0; right < n; right++) {\r\n        if (right > k) {  // 窗口大小超过k+1时\r\n            s.erase(nums[right - k - 1]);  // 移除窗口最左边的元素\r\n        }\r\n        if (s.count(nums[right])) {  // 当前数字已在窗口中\r\n            return true;  // 找到符合条件的重复元素\r\n        }\r\n        s.emplace(nums[right]);  // 将当前数字加入窗口\r\n    }\r\n    return false;  // 未找到符合条件的重复元素\r\n}\r\n```\r\n\r\n3. **具体执行过程**\r\n以示例 `nums = [1,2,3,1], k = 3` 为例：\r\n- right=0: 集合={1}\r\n- right=1: 集合={1,2}\r\n- right=2: 集合={1,2,3}\r\n- right=3: 发现1已在集合中,返回true\r\n\r\n4. **复杂度分析**\r\n- 时间复杂度：O(n)，其中n是数组长度\r\n- 空间复杂度：O(k)，哈希集合最多存储k+1个元素\r\n\r\n这种实现方式非常高效,通过维护固定大小的窗口,保证了任意两个元素的下标差不超过k。"}]}