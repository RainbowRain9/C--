{"data":[{"name":"2024-12-09 21:18:01","id":1733750281944,"body":"好的，我将使用这个模板来详细分析LeetCode 809题目“情感丰富的文字”。\r\n\r\n# 809. 情感丰富的文字\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- **题目的具体要求**: 给定一个字符串 `s` 和一个字符串数组 `words`，判断 `words` 中有多少个字符串可以通过扩展字符的方式变成 `s`。\r\n- **输入输出格式**:\r\n  - 输入: 一个字符串 `s` 和一个字符串数组 `words`。\r\n  - 输出: 一个整数，表示可以扩展成 `s` 的字符串数量。\r\n- **约束条件**:\r\n  - 字符串 `s` 和 `words` 中的每个字符串长度在 [1, 100] 之间。\r\n  - 字符串只包含小写字母。\r\n\r\n### 2. 关键概念\r\n- **需要理解的关键点**: 字符扩展的规则，即字符可以重复但不能减少，且重复后的字符数量必须大于等于3。\r\n- **核心的数据结构**: 字符串和数组。\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：s = \"heeellooo\", words = [\"hello\", \"hi\", \"helo\"]\r\n输出：1\r\n解释：\r\n1. \"hello\" 可以扩展成 \"heeellooo\"。\r\n2. \"hi\" 和 \"helo\" 无法扩展成 \"heeellooo\"。\r\n3. 最终结果是 1。\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：s = \"a\", words = [\"a\", \"aa\", \"aaa\"]\r\n输出：1\r\n解释：只有 \"a\" 可以扩展成 \"a\"。\r\n```\r\n\r\n### 3. 边界情况\r\n```\r\n输入：s = \"aaa\", words = [\"a\", \"aa\", \"aaa\"]\r\n输出：3\r\n解释：所有字符串都可以扩展成 \"aaa\"。\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n- **主要解题思路**: 使用双指针遍历 `s` 和 `word`，统计每个字符的连续出现次数，判断是否满足扩展条件。\r\n- **算法选择原因**: 双指针法可以高效地比较两个字符串的字符和其连续出现次数。\r\n- **可能的其他方案**: 直接模拟字符扩展，但效率较低。\r\n\r\n### 2. 具体流程\r\n- 初始化两个指针 `i` 和 `j` 分别指向 `s` 和 `word`。\r\n- 遍历 `s` 和 `word`，统计每个字符的连续出现次数。\r\n- 判断 `s` 中字符的数量是否满足扩展条件。\r\n- 如果所有字符都满足条件，返回 `true`，否则返回 `false`。\r\n\r\n## 四、代码详解\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int expressiveWords(string s, vector<string>& words) {\r\n        int ans = 0;\r\n        for (const string& word : words) {\r\n            if (isExpressive(s, word)) {\r\n                ans++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    bool isExpressive(const string& source, const string& word) {\r\n        int i = 0, j = 0;\r\n        while (i < source.length() && j < word.length()) {\r\n            if (source[i] != word[j]) {\r\n                return false;\r\n            }\r\n\r\n            int source_count = 1;\r\n            while (i + 1 < source.length() && source[i] == source[i + 1]) {\r\n                source_count++;\r\n                i++;\r\n            }\r\n\r\n            int word_count = 1;\r\n            while (j + 1 < word.length() && word[j] == word[j + 1]) {\r\n                word_count++;\r\n                j++;\r\n            }\r\n\r\n            if (source_count < word_count || (source_count < 3 && source_count != word_count)) {\r\n                return false;\r\n            }\r\n\r\n            i++;\r\n            j++;\r\n        }\r\n\r\n        return i == source.length() && j == word.length();\r\n    }\r\n};\r\n```\r\n\r\n### 代码优化\r\n```cpp\r\n// 代码已经较为简洁，主要是通过双指针和计数来实现\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- **算法正确性分析**: 通过双指针和计数法，确保每个字符的数量满足扩展条件。\r\n- **关键步骤证明**: 每次比较字符和其连续出现次数，确保符合题目要求。\r\n\r\n### 2. 重要细节\r\n- **关键实现细节**: 双指针的使用和字符计数。\r\n- **易错点提醒**: 注意字符数量的比较条件。\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(N * M)\r\n  - N 是 `words` 的长度，M 是字符串的平均长度。\r\n  - 每个字符串都需要遍历一次。\r\n- **空间复杂度**: O(1)\r\n  - 只使用了常数额外空间。\r\n\r\n## 七、常见错误\r\n\r\n1. **错误类型一**\r\n```cpp\r\n// 忘记比较字符数量\r\nif (source[i] != word[j]) {\r\n    return false;\r\n}\r\n```\r\n\r\n2. **错误类型二**\r\n```cpp\r\n// 错误的计数条件\r\nif (source_count < word_count) {\r\n    return false;\r\n}\r\n```\r\n\r\n## 八、相关题目\r\n- [相关题目1](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\r\n- [相关题目2](https://leetcode.cn/problems/valid-parentheses/)\r\n\r\n---\r\n\r\n注意事项：\r\n1. 示例分析部分应该尽可能详细，帮助理解算法。\r\n2. 对于复杂问题，可以使用图解说明。\r\n3. 特殊情况和边界情况的示例很重要。\r\n4. 每个示例都应该有清晰的解释。\r\n"}]}