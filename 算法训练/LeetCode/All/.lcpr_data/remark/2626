{"data":[{"name":"2024-11-19 20:26:33","id":1732019193881,"body":"# LeetCode 2537 - 统计好子数组的数目\r\n\r\n```thinking\r\n让我系统地分析这道题...\r\n\r\n首先理解题目要求：\r\n- 需要找到所有\"好子数组\"的数量\r\n- \"好子数组\"的定义是至少有k对相同的数字\r\n- 子数组必须是连续的\r\n\r\n解题思路的关键点：\r\n- 这是一个需要统计区间内配对数的问题\r\n- 可以用滑动窗口来维护一个有效区间\r\n- 对于每个右端点，需要找到最左边的位置，使得区间内的配对数>=k\r\n\r\n我觉得可以这样设计算法：\r\n1. 用哈希表记录每个数字出现的次数\r\n2. 当加入新数字时，新增的配对数是当前这个数字之前出现的次数\r\n3. 当移除数字时，减少的配对数是当前这个数字剩余的次数\r\n\r\n关于复杂度：\r\n- 时间复杂度应该是O(n)，因为每个元素最多被访问两次（加入和移除）\r\n- 空间复杂度是O(n)，主要是哈希表的开销\r\n\r\n让我想想这个解法的正确性：\r\n- 对于每个右端点，我们都能找到最左边的合法位置\r\n- 从这个左边界到右边界之间的所有位置都是合法的左端点\r\n- 所以对于每个右端点，加上left就是以当前位置为右端点的好子数组的数量\r\n\r\n嗯，这个思路应该是完整和正确的。\r\n```\r\n\r\n## 题目描述\r\n给你一个整数数组 `nums` 和一个整数 `k`，请你统计并返回 `nums` 的好子数组的数目。\r\n\r\n如果一个子数组中至少有 `k` 对下标 `(i, j)` 满足 `i < j` 且 `arr[i] == arr[j]`，那么称它是一个**好子数组**。\r\n\r\n## 示例\r\n### 示例 1\r\n```\r\n输入：nums = [1,1,1,1,1], k = 10\r\n输出：1\r\n解释：唯一的好子数组是这个数组本身。\r\n```\r\n\r\n### 示例 2\r\n```\r\n输入：nums = [3,1,4,3,2,2,4], k = 2\r\n输出：4\r\n解释：总共有 4 个不同的好子数组：\r\n- [3,1,4,3] 有 2 对。\r\n- [3,1,4,3,2] 有 2 对。\r\n- [1,4,3,2,2] 有 2 对。\r\n- [4,3,2,2,4] 有 2 对。\r\n```\r\n\r\n## 解题思路\r\n### 算法流程\r\n1. 使用滑动窗口来维护一个区间，用哈希表统计每个数字出现的次数\r\n2. 对于每个右端点：\r\n   - 将当前数字加入窗口，更新配对数\r\n   - 如果配对数超过k，就尽可能地收缩左边界\r\n   - 此时left左边的所有位置都可以作为左端点形成好子数组\r\n3. 累加每个右端点对应的左端点数量\r\n\r\n### 代码实现\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    long long countGood(vector<int>& nums, int k) {\r\n        int n = nums.size();\r\n        unordered_map<int, int> cnt;  // 统计每个数字出现的次数\r\n        long long pairs = 0;  // 当前窗口内的配对数\r\n        int left = 0;  // 左边界\r\n        long long ans = 0;  // 结果\r\n        \r\n        // 遍历每个右端点\r\n        for (int x : nums) {\r\n            // 加入新数字，更新配对数\r\n            pairs += cnt[x]++;\r\n            \r\n            // 如果配对数超过k，尽可能收缩左边界\r\n            while (pairs >= k) {\r\n                pairs -= --cnt[nums[left]];\r\n                left++;\r\n            }\r\n            \r\n            // 累加以当前位置为右端点的好子数组数量\r\n            ans += left;\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 是数组长度。每个元素最多被加入和移除一次。\r\n- 空间复杂度：O(n)，主要是哈希表的空间开销。\r\n\r\n## 关键点解析\r\n1. **滑动窗口技巧**：\r\n   - 使用滑动窗口维护一个满足条件的区间\r\n   - 右指针不断向右移动，左指针根据条件适时收缩\r\n\r\n2. **配对数的计算**：\r\n   - 当加入一个新数字时，新增的配对数是这个数字之前出现的次数\r\n   - 当移除一个数字时，减少的配对数是这个数字剩余的次数\r\n\r\n3. **结果的累加**：\r\n   - 对于每个右端点，left左边的所有位置都可以作为左端点形成好子数组\r\n   - 因此每次加上left就是当前右端点对应的好子数组数量\r\n\r\n4. **数据类型的选择**：\r\n   - 使用 `long long` 类型来避免整数溢出\r\n   - 配对数和结果都可能超过int范围\r\n\r\n## 注意事项\r\n1. 需要使用 `long long` 类型来存储结果，因为最终答案可能很大\r\n2. 移除元素时要先减少计数再减少配对数，顺序很重要\r\n3. 滑动窗口的维护需要特别注意边界条件"}]}