{"data":[{"name":"2024-11-25 17:55:07","id":1732528507482,"body":"```thinking\r\n让我深入分析一下这道题...\r\n\r\n首先理解题目本质：\r\n- 需要在数组中复写所有的0\r\n- 复写意味着把0变成两个0\r\n- 数组长度不变，意味着末尾的元素会被挤出去\r\n\r\n关键点在于：\r\n1. 如何在原地完成操作？\r\n2. 如何处理数组长度不变的约束？\r\n3. 如何避免元素被覆盖导致信息丢失？\r\n\r\n代码实现采用了两次遍历的巧妙方法：\r\n1. 第一次遍历计算复写后每个元素的最终位置\r\n2. 第二次从后往前复写，避免覆盖问题\r\n\r\n让我详细解释每个步骤，并举例说明整个过程...\r\n```\r\n\r\n# 1089.复写零\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 给定一个固定长度的整数数组 `arr`\r\n- 将数组中的每个 0 复写一次\r\n- 将其余数字左移\r\n- 不要创建新数组，必须在原数组上修改\r\n\r\n### 2. 关键概念\r\n- 原地修改：不使用额外数组\r\n- 复写零：一个0变成两个0\r\n- 数组长度不变：末尾元素会被挤出\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：[1,0,2,3,0,4,5,0]\r\n输出：[1,0,0,2,3,0,0,4]\r\n解释：\r\n1. 第一个0被复写，后面元素右移\r\n2. 第二个0被复写，继续右移\r\n3. 第三个0的复写部分被截断（超出数组长度）\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：[1,2,3]\r\n输出：[1,2,3]\r\n解释：没有0，数组保持不变\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n使用两次遍历：\r\n1. 第一次遍历：计算每个元素在复写后的位置\r\n2. 第二次遍历：从后往前复写元素\r\n\r\n### 2. 具体流程\r\n1. 第一次遍历：\r\n   - 统计每个元素复写后的位置\r\n   - 遇到0时位置加2，其他数字加1\r\n   \r\n2. 第二次遍历：\r\n   - 从后往前移动元素\r\n   - 遇到0时复写两次\r\n   - 注意数组边界\r\n\r\n## 四、代码详解\r\n\r\n```cpp:算法训练/LeetCode/All/1089-复写零.cpp\r\nclass Solution {\r\npublic:\r\n    void duplicateZeros(vector<int>& arr) {\r\n        int n = arr.size();\r\n        int i = 0, j = 0;\r\n        // 第一次遍历：计算位置\r\n        for (; j < n; i++) {\r\n            if (arr[i] == 0) \r\n                j += 2;  // 遇到0时跳两步\r\n            else \r\n                j++;    // 普通数字跳一步\r\n        }\r\n        i--;  // 回到最后一个有效位置\r\n        j--;  // 回到实际的末尾位置\r\n        \r\n        // 第二次遍历：从后往前复写\r\n        while (i >= 0) {\r\n            if (j < n)  // 在数组范围内才复写\r\n                arr[j] = arr[i];\r\n            if (arr[i] == 0) {  // 处理0的复写\r\n                j--;\r\n                if (j < n)\r\n                    arr[j] = 0;\r\n            }\r\n            i--;\r\n            j--;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n### 代码执行过程示例\r\n以 `[1,0,2,3,0,4,5,0]` 为例：\r\n\r\n1. 第一次遍历：\r\n   ```\r\n   i=0: j=1  (1)\r\n   i=1: j=3  (0)\r\n   i=2: j=4  (2)\r\n   i=3: j=5  (3)\r\n   i=4: j=7  (0)\r\n   i=5: j=8  (4)\r\n   ```\r\n\r\n2. 第二次遍历：\r\n   ```\r\n   [1,0,2,3,0,4,5,0] 初始\r\n   [1,0,2,3,0,4,5,0] 复写最后的4\r\n   [1,0,2,3,0,0,4,0] 复写0\r\n   [1,0,2,3,0,0,4,0] 复写3\r\n   [1,0,0,2,3,0,0,4] 最终结果\r\n   ```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- 从后往前复写避免了覆盖问题\r\n- 第一次遍历确保了正确的位置计算\r\n- 边界检查保证了数组不会越界\r\n\r\n### 2. 重要细节\r\n- i和j的初始化和调整\r\n- 数组边界的检查\r\n- 0的特殊处理\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(n)\r\n  - 两次遍历，每次O(n)\r\n- **空间复杂度**: O(1)\r\n  - 只使用了常数额外空间\r\n\r\n## 七、常见错误\r\n\r\n1. **直接从前往后复写**\r\n```cpp\r\n// 错误示例：会导致数据覆盖\r\nfor (int i = 0; i < n; i++) {\r\n    if (arr[i] == 0) {\r\n        // 直接移动会覆盖后面的数据\r\n    }\r\n}\r\n```\r\n\r\n2. **使用额外数组**\r\n```cpp\r\n// 不符合题目要求的解法\r\nvector<int> temp = arr;\r\n// 使用临时数组复写\r\n```\r\n\r\n## 八、相关题目\r\n- [283. 移动零](https://leetcode.cn/problems/move-zeroes/)\r\n- [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)\r\n\r\n这些题目都涉及数组的原地修改操作。"}]}