{"data":[{"name":"2024-11-18 15:35:18","id":1731915318734,"body":"\r\n# 1234. 替换子串得到平衡字符串\r\n\r\n### 核心思路\r\n这是一道使用滑动窗口解决的问题。目标是找到一个最小的子串，将其替换后使得整个字符串变成平衡字符串（每个字符出现次数相等）。\r\n\r\n### 关键点\r\n1. 平衡字符串要求每个字符('Q','W','E','R')出现次数都是 n/4\r\n2. 使用滑动窗口找到最小的需要替换的子串\r\n3. 判断条件：窗口外的字符数量都不超过 n/4 时，窗口内的字符就可以被替换\r\n\r\n### 代码\r\n```cpp\r\nclass Solution\r\n{\r\nprivate:\r\n    bool isBalanced(const int cnt[], int partial)\r\n    {\r\n        return cnt['Q'] <= partial && cnt['W'] <= partial &&\r\n               cnt['E'] <= partial && cnt['R'] <= partial;\r\n    }\r\n\r\npublic:\r\n    int balancedString(string s)\r\n    {\r\n        int cnt[128] = {0};\r\n        int n = s.length();\r\n        int partial = n / 4;\r\n        for (char c : s)\r\n        {\r\n            cnt[c]++;\r\n        }\r\n        if(isBalanced(cnt, partial))\r\n        {\r\n            return 0;\r\n        }\r\n        int left = 0, ans = n;\r\n        for (int right = 0; right < n; right++)\r\n        {\r\n            cnt[s[right]]--;\r\n            while (left <= right && isBalanced(cnt, partial))\r\n            {\r\n                ans = min(ans, right - left + 1);\r\n                cnt[s[left++]]++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### 代码模拟运行\r\n让我们以示例 `s = \"QQER\"` 来模拟运行过程：\r\n\r\n1. **初始化**:\r\n```cpp\r\nn = 4\r\npartial = n/4 = 1  // 每个字符应该出现的次数\r\ncnt[] 初始统计: Q:2, W:0, E:1, R:1\r\n```\r\n\r\n2. **滑动窗口过程**:\r\n```\r\n初始状态: cnt[Q]=2, cnt[W]=0, cnt[E]=1, cnt[R]=1\r\n         Q  Q  E  R\r\n         ↑\r\n         right\r\n\r\n第1步:   Q  Q  E  R\r\n         ↑\r\n     left,right\r\n     - cnt[Q]减1变为1\r\n     - 检查是否平衡：否\r\n     \r\n第2步:   Q  Q  E  R\r\n         ↑  ↑\r\n        left right\r\n     - cnt[Q]减1变为0\r\n     - 检查是否平衡：是\r\n     - 更新ans = 2\r\n     \r\n第3步:   Q  Q  E  R\r\n            ↑  ↑\r\n           left right\r\n     ...继续滑动\r\n```\r\n\r\n### 关键步骤解释\r\n1. **计数阶段**：\r\n```cpp\r\nint cnt[128] = {0};\r\nfor (char c : s) {\r\n    cnt[c]++;\r\n}\r\n```\r\n首先统计每个字符的出现次数。\r\n\r\n2. **判断平衡的辅助函数**：\r\n```cpp\r\nbool isBalanced(const int cnt[], int partial) {\r\n    return cnt['Q'] <= partial && cnt['W'] <= partial &&\r\n           cnt['E'] <= partial && cnt['R'] <= partial;\r\n}\r\n```\r\n检查窗口外的每个字符数量是否都不超过 n/4。\r\n\r\n3. **滑动窗口核心逻辑**：\r\n```cpp\r\nwhile (left <= right && isBalanced(cnt, partial)) {\r\n    ans = min(ans, right - left + 1);  // 更新最小窗口大小\r\n    cnt[s[left++]]++;  // 缩小窗口\r\n}\r\n```\r\n当找到一个可行解时，尝试通过移动左边界来找到更小的窗口。\r\n\r\n### 时间复杂度\r\n- 时间复杂度：O(n)，其中 n 是字符串长度\r\n- 空间复杂度：O(1)，使用固定大小的数组存储计数\r\n\r\n### 运行结果\r\n对于输入 `\"QQER\"`：\r\n- 输出：`1`\r\n- 解释：只需要替换一个 'Q' 为 'W'，使得每个字符都出现一次"}]}