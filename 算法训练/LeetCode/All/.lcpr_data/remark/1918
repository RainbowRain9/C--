{"data":[{"name":"2024-11-25 16:03:27","id":1732521807143,"body":"```thinking\r\n让我基于这个模板来详细分析1793题...\r\n\r\n首先整理题目的核心要点：\r\n1. 题目要求找一个包含索引k的子数组，使得 最小值×长度 最大\r\n2. 这是一个最优化问题，需要在子数组长度和最小值之间找平衡\r\n\r\n关键概念：\r\n- 子数组：连续的数组片段\r\n- 分数计算：min(subarray) * length\r\n- 贪心策略：每次选择较优的扩展方向\r\n\r\n示例分析很重要：\r\n[1,4,3,7,4,5], k=3 这个例子很好地展示了算法流程\r\n- 从7开始\r\n- 向右扩展到4、5\r\n- 向左扩展到3\r\n可以用来说明贪心策略的正确性\r\n\r\n解题思路采用双指针+贪心：\r\n1. 从k开始向两边扩展\r\n2. 每次选择较大的数字方向扩展\r\n3. 动态维护最小值和计算分数\r\n\r\n代码结构也很清晰：\r\n- 初始化部分\r\n- 扩展循环\r\n- 分数更新\r\n\r\n让我组织一下完整的题解结构...\r\n```\r\n\r\n# 1793.好子数组的最大分数\r\n\r\n## 一、题目分析\r\n\r\n### 1. 题目要求\r\n- 给定一个整数数组`nums`和整数`k`\r\n- 找到一个包含索引`k`的子数组\r\n- 计算子数组的分数：子数组中的最小值 × 子数组的长度\r\n- 返回可能的最大分数\r\n\r\n### 2. 关键概念\r\n- 子数组：必须是连续的数组片段\r\n- 分数计算：min(subarray) × length\r\n- 必须包含索引k：这是子数组的强制要求\r\n\r\n## 二、示例分析\r\n\r\n### 1. 基本示例\r\n```\r\n输入：nums = [1,4,3,7,4,5], k = 3\r\n输出：15\r\n解释：\r\n1. 最优子数组为[7,4,5]\r\n2. 最小值为4，长度为3\r\n3. 分数 = 4 × 3 = 12\r\n```\r\n\r\n### 2. 特殊情况\r\n```\r\n输入：nums = [5,5,4,5,4,1,1,1], k = 0\r\n输出：20\r\n解释：\r\n最优子数组为[5,5,4,5,4]，最小值4，长度5，分数20\r\n```\r\n\r\n## 三、解题思路\r\n\r\n### 1. 核心策略\r\n- 使用双指针从索引k开始向两边扩展\r\n- 贪心策略：每次选择左右两边较大的数字进行扩展\r\n- 动态维护当前子数组的最小值和最大分数\r\n\r\n### 2. 具体流程\r\n1. 初始化：从位置k开始，初始最小值为nums[k]\r\n2. 向两边扩展：\r\n   - 比较左右两边的值，选择较大的方向扩展\r\n   - 更新最小值和子数组长度\r\n   - 计算新的分数并更新答案\r\n3. 重复扩展过程直到无法继续\r\n\r\n## 四、代码详解\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maximumScore(vector<int>& nums, int k) {\r\n        int n = nums.size();\r\n        // 初始化：从k位置开始\r\n        int ans = nums[k];\r\n        int min_h = nums[k];\r\n        int left = k, right = k;\r\n        \r\n        // 向两边扩展n-1次\r\n        for (int i = 0; i < n-1; i++) {\r\n            // 选择左右两边较大的数扩展\r\n            if (right == n-1 || left && nums[left-1] > nums[right+1]) {\r\n                min_h = min(min_h, nums[--left]);  // 向左扩展\r\n            } else {\r\n                min_h = min(min_h, nums[++right]); // 向右扩展\r\n            }\r\n            // 更新答案\r\n            ans = max(ans, min_h * (right - left + 1));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 五、算法分析\r\n\r\n### 1. 正确性证明\r\n- 贪心策略的正确性：\r\n  1. 每次选择较大的数扩展可以尽量保持较大的最小值\r\n  2. 同时子数组长度在增加\r\n  3. 这种策略能保证不会错过最优解\r\n\r\n### 2. 重要细节\r\n- 边界条件处理：right到达数组末尾时只能向左扩展\r\n- left > 0时才能向左扩展\r\n- 每次扩展后都要更新最小值和计算新的分数\r\n\r\n## 六、复杂度分析\r\n\r\n- **时间复杂度**: O(n)\r\n  - 只需要遍历一次数组\r\n  - 每次操作都是O(1)的\r\n- **空间复杂度**: O(1)\r\n  - 只使用了常数额外空间\r\n\r\n## 七、相关题目\r\n- [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)\r\n- [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)\r\n\r\n这些题目都涉及到数组中的最小值和区间操作的概念。"}]}