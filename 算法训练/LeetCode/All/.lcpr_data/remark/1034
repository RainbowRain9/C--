{"data":[{"name":"2024-11-19 11:07:46","id":1731985666748,"body":"我来详细讲解这道 LeetCode 992 题的解法。这是一道使用滑动窗口技巧的经典题目。\r\n\r\n### 核心思路\r\n\r\n这道题的巧妙之处在于将\"恰好包含 k 个不同整数\"转化为\"最多包含 k 个不同整数\"减去\"最多包含 k-1 个不同整数\"。\r\n\r\n### 代码分析\r\n\r\n主要包含两个函数：\r\n\r\n1. `subarraysWithKDistinct`: 主函数，使用差值法求解\r\n2. `atMostK`: 辅助函数，计算最多包含 k 个不同整数的子数组个数\r\n\r\n让我们看看 `atMostK` 函数是如何工作的：\r\n\r\n```cpp:算法训练/LeetCode/All/992-K 个不同整数的子数组.cpp\r\nint atMostK(vector<int> &nums, int k)\r\n{\r\n    unordered_map<int, int> cnt;  // 记录每个数字出现的次数\r\n    int n = nums.size();\r\n    int left = 0, ans = 0;\r\n    \r\n    for (int right = 0; right < n; right++)\r\n    {\r\n        cnt[nums[right]]++;  // 将右边界的数字加入窗口\r\n        \r\n        // 当窗口中不同数字超过k个时，收缩左边界\r\n        while (cnt.size() > k)\r\n        {\r\n            int x = nums[left];\r\n            if (--cnt[x] == 0)  // 如果某个数字的计数变为0，从map中删除\r\n                cnt.erase(x);\r\n            left++;\r\n        }\r\n        \r\n        // 对于当前右边界，所有可能的子数组数量\r\n        ans += right - left + 1;\r\n    }\r\n    return ans;\r\n}\r\n```\r\n\r\n### 为什么 `right - left + 1` 是正确的？\r\n\r\n对于每个右边界 `right`，我们计算以它为结尾的所有合法子数组数量：\r\n- 假设当前左边界是 `left`\r\n- 那么所有可能的子数组就是：\r\n  - `[left, right]`\r\n  - `[left+1, right]`\r\n  - `[left+2, right]`\r\n  - ...\r\n  - `[right, right]`\r\n- 这些子数组的数量正好是 `right - left + 1`\r\n\r\n### 时间复杂度\r\n\r\n- 时间复杂度：O(n)，其中 n 是数组长度\r\n- 空间复杂度：O(k)，哈希表的大小不会超过 k\r\n\r\n这个解法的优雅之处在于将一个\"恰好\"问题转化为两个\"最多\"问题，而\"最多\"问题可以用滑动窗口高效解决。"}]}