{"data":[{"name":"2024-11-23 13:43:11","id":1732340591407,"body":"```thinking\r\n让我组织一个清晰的题解笔记...\r\n\r\n需要包含的要点:\r\n1. 题目描述和要求\r\n2. 解题思路和关键点\r\n3. 代码实现\r\n4. 复杂度分析\r\n5. 具体例子演示\r\n\r\n格式上要用 markdown 清晰地组织各个部分。\r\n代码部分要有详细注释说明。\r\n\r\n这道题的关键在于排序后利用双指针降低复杂度,我要重点说明这一点。\r\n```\r\n\r\n# [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)\r\n\r\n## 题目描述\r\n\r\n给定一个包含非负整数的数组 `nums` ，返回其中可以组成三角形三条边的三元组个数。\r\n\r\n## 解题思路\r\n\r\n### 关键点\r\n\r\n1. **三角形条件**：任意两边之和大于第三边\r\n2. **排序优化**：排序后只需验证较小两边之和大于最大边\r\n3. **双指针**：固定最大边，用双指针找其他两边\r\n\r\n### 算法流程\r\n\r\n1. 对数组进行升序排序\r\n2. 固定最大边 k (从索引 2 开始)\r\n3. 使用双指针 i、j 在 [0, k-1] 范围内寻找其他两边\r\n4. 当 nums[i] + nums[j] > nums[k] 时，[i, j-1] 范围内的所有数都可以和 nums[j] 组成有效三角形\r\n\r\n## 代码实现\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int triangleNumber(vector<int>& nums) {\r\n        int n = nums.size();\r\n        // 先排序，保证 nums[k] >= nums[j] >= nums[i]\r\n        sort(nums.begin(), nums.end());\r\n        int ans = 0;\r\n        \r\n        // 固定最大边 k\r\n        for (int k = 2; k < n; k++) {\r\n            // 双指针 i、j 在 [0,k-1] 范围内寻找其他两边\r\n            int i = 0, j = k - 1;\r\n            while (i < j) {\r\n                if (nums[i] + nums[j] > nums[k]) {\r\n                    // 找到有效组合，[i,j-1] 范围内的都是有效的\r\n                    ans += j - i;\r\n                    j--;\r\n                } else {\r\n                    // 和不够大，需要增大 i\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- **时间复杂度**: O(n²)\r\n  - 排序需要 O(nlogn)\r\n  - 双指针遍历需要 O(n²)\r\n- **空间复杂度**: O(1)\r\n  - 只使用了常数额外空间\r\n\r\n## 示例演示\r\n\r\n输入：`nums = [2,2,3,4]`\r\n\r\n1. 排序后：`[2,2,3,4]`\r\n2. k = 2 (nums[k] = 3)时：\r\n   - i = 0, j = 1: 2 + 2 > 3，找到 1 个三角形\r\n3. k = 3 (nums[k] = 4)时：\r\n   - i = 0, j = 2: 2 + 3 > 4，找到 2 个三角形\r\n\r\n最终结果：3\r\n\r\n## 相关题目\r\n\r\n- [15. 三数之和](https://leetcode.cn/problems/3sum/)\r\n- [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)"}]}