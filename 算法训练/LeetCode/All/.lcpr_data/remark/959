{"data":[{"name":"2024-11-23 14:31:43","id":1732343503526,"body":"\r\n\r\n```thinking\r\n让我深入分析这道题...\r\n\r\n这是一道三数之和的变体，关键点在于：\r\n1. 需要处理重复元素的计数\r\n2. 使用取模避免溢出\r\n3. 双指针的移动策略很巧妙\r\n\r\n代码的精妙之处：\r\n1. 先排序，这样可以更容易处理重复元素\r\n2. 当找到目标和时，分两种情况处理：\r\n   - 两端数字不同：统计重复次数后相乘\r\n   - 两端数字相同：使用组合数公式\r\n\r\n需要重点解释：\r\n1. 为什么要用 mod\r\n2. 如何处理重复元素\r\n3. 双指针的移动条件\r\n4. 时间复杂度分析\r\n\r\n让我组织一个详细的讲解...\r\n```\r\n\r\n# [923. 三数之和的多种可能](https://leetcode.cn/problems/3sum-with-multiplicity/)\r\n\r\n## 一、题目解析\r\n\r\n### 1. 题目要求\r\n- 给定一个整数数组 `arr` 和目标值 `target`\r\n- 返回由 `arr` 中三个不同索引 `i`、`j` 和 `k` 组成的三元组数目，满足：\r\n  - arr[i] + arr[j] + arr[k] == target\r\n  - i < j < k\r\n\r\n### 2. 示例\r\n```\r\n输入：arr = [1,1,2,2,3,3,4,4,5,5], target = 8\r\n输出：20\r\n```\r\n\r\n### 3. 约束条件\r\n- 答案需要对 10⁹ + 7 取模\r\n- 需要考虑重复元素\r\n\r\n## 二、解题思路\r\n\r\n### 1. 核心思想\r\n- 排序 + 双指针\r\n- 特殊处理重复元素的计数\r\n\r\n### 2. 算法流程\r\n1. 对数组排序\r\n2. 固定第一个数 x = arr[i]\r\n3. 使用双指针 j 和 k 在剩余数组中寻找和为 target-x 的两个数\r\n4. 当找到目标和时，分两种情况处理重复元素：\r\n   - arr[j] == arr[k]：使用组合数公式\r\n   - arr[j] != arr[k]：计算两端重复元素个数的乘积\r\n\r\n## 三、代码详解\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    const int mod = 1000000007;\r\n    int threeSumMulti(vector<int>& arr, int target) {\r\n        int n = arr.size();\r\n        // 排序便于使用双指针和处理重复元素\r\n        sort(arr.begin(), arr.end());\r\n        int ans = 0;\r\n        \r\n        // 固定第一个数\r\n        for (int i = 0; i < n - 2; i++) {\r\n            int x = arr[i];\r\n            int j = i + 1, k = n - 1;\r\n            \r\n            // 双指针寻找剩余两个数\r\n            while (j < k) {\r\n                int sum = x + arr[j] + arr[k];\r\n                if (sum < target) {\r\n                    j++;  // 和太小，增大 j\r\n                }\r\n                else if (sum > target) {\r\n                    k--;  // 和太大，减小 k\r\n                }\r\n                else if (arr[j] == arr[k]) {\r\n                    // 两端数字相同，使用组合数公式\r\n                    int tmp = k - j + 1;\r\n                    ans = (ans + tmp * (tmp - 1) / 2) % mod;\r\n                    break;\r\n                }\r\n                else {\r\n                    // 两端数字不同，计算重复元素个数\r\n                    int cnt1 = 1, cnt2 = 1;\r\n                    while (j + 1 < k && arr[j] == arr[j + 1]) {\r\n                        cnt1++;\r\n                        j++;\r\n                    }\r\n                    while (k - 1 > j && arr[k] == arr[k - 1]) {\r\n                        cnt2++;\r\n                        k--;\r\n                    }\r\n                    ans = (ans + cnt1 * cnt2) % mod;\r\n                    j++;\r\n                    k--;\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 四、重点解析\r\n\r\n### 1. 排序的作用\r\n- 使得重复元素相邻，便于统计重复次数\r\n- 能够使用双指针降低时间复杂度\r\n- 便于剪枝优化\r\n\r\n### 2. 重复元素处理\r\n当找到目标和时，分两种情况：\r\n1. arr[j] == arr[k]：\r\n   - 表示中间所有数都相同\r\n   - 使用组合数公式 C(n,2) = n*(n-1)/2\r\n2. arr[j] != arr[k]：\r\n   - 分别统计左右两端重复元素的个数\r\n   - 结果为两个数的乘积\r\n\r\n### 3. 取模说明\r\n- 使用 const int mod = 1000000007\r\n- 每次累加结果时都要取模：ans = (ans + count) % mod\r\n- 避免整数溢出\r\n\r\n### 4. 双指针移动策略\r\n- sum < target：j++ 增大和\r\n- sum > target：k-- 减小和\r\n- sum == target：根据重复元素情况处理\r\n\r\n## 五、复杂度分析\r\n\r\n### 1. 时间复杂度：O(n²)\r\n- 排序：O(nlogn)\r\n- 双指针遍历：O(n²)\r\n- 总体：O(n²)\r\n\r\n### 2. 空间复杂度：O(1)\r\n- 只使用了常数额外空间\r\n\r\n## 六、举例说明\r\n\r\n以 arr = [1,1,2,2,3,3], target = 5 为例：\r\n\r\n1. 固定 x = 1：\r\n   - 寻找和为 4 的两个数\r\n   - 找到 (1,3)，重复次数：2*2=4\r\n\r\n2. 固定 x = 2：\r\n   - 寻找和为 3 的两个数\r\n   - 找到 (1,2)，重复次数：2*1=2\r\n\r\n总计：6 种可能\r\n\r\n## 七、相关题目\r\n- [15. 三数之和](https://leetcode.cn/problems/3sum/)\r\n- [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)\r\n- [18. 四数之和](https://leetcode.cn/problems/4sum/)"}]}