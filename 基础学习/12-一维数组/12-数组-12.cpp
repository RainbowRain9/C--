/*
描述
输入m个数字，输出其中出现次数最多的数字（保证只会有一个数字出现次数最多，不存在并列第一多）

输入
一个正整数n，表示n组案例。

每组案例中，首先是一个正整数m，然后是m个整数。

输出
针对每组案例，输出这m个整数中，出现次数最多的数字（保证只有一个数字）。

每组案例输出完都要换行。

样例输入
1

5 1 2 3 1 4

样例输出
1
*/
#include <iostream>
using namespace std;

int main() {
    int n; // 存储案例的数量
    cin >> n; // 读取案例数量
    while (n--) { // 对于每个案例
        int m; // 存储每个案例中的整数数量
        cin >> m; // 读取整数的数量
        int a[m]; // 定义数组存储这些整数
        int cnt[m] = {0}; // 定义数组存储每个数字出现的次数，并初始化为0

        // 读取m个整数到数组a中，并初始化对应的出现次数为0
        for (int i = 0; i < m; i++) {
            cin >> a[i];
        }

        // 计算每个数字出现的次数
        for (size_t i = 0; i < m; i++) {
            for (int j = 0; j < m; j++) {
                // 如果a[i]和a[j]相等，并且不是同一个位置的数字，则计数增加
                if (a[i] == a[j] && i != j) {
                    cnt[i]++;
                }
            }
        }

        // 初始化最频繁出现的数字及其计数
        int max = cnt[0];
        int pos = 0;

        // 找出出现次数最多的数字
        for (size_t i = 0; i < m; i++) {
            // 如果当前数字出现的次数大于已知的最大次数，则更新最大次数和对应的位置
            if (cnt[i] > max) {
                max = cnt[i];
                pos = i;
            }
        }

        // 输出出现次数最多的数字
        cout << a[pos] << endl; // 注意：这里应该输出的是数字，而不是位置索引
    }
    return 0;
}