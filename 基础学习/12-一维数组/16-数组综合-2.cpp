/*
描述
数组a中的an个元素是按照从小到大的顺序排列，即下标较小的元素值不会大于下标较大的元素值。

数组b中的bn个元素也是按照从小到大的顺序排列。

现在要求综合地考虑数组a和数组b中的所有元素，按从小到大的顺序依次输出所有an+bn个元素值。

输入
一个正整数n，表示有n组案例。

每组案例中，先是两个正整数an和bn，分别表示数组a的元素个数和数组b的元素个数；
（an<=1000000, bn<=1000000）

然后是an个从小到大排序过的整数，表示a数组各元素的值；

最后是bn个从小到大排序过的整数，表示b数组各元素的值。

输出
针对每组案例，输出an+bn个数字，表示c数组里各元素的值，每个数字之间有一个空格，
最后一个数字后面不要有空格。
每组案例输出完都要换行。

样例输入
1

5 3

2 4 6 8 10

1 4 9

样例输出
1 2 4 4 6 8 9 10

提示说明
不要用到排序
*/

#include <iostream>
using namespace std;

int main() {
    int n; // 存储测试用例的数量
    cin >> n; // 读取测试用例的数量
    while (n--) { // 对于每个测试用例
        int m, k; // 分别存储数组a和b的元素个数
        cin >> m >> k; // 读取数组a和b的元素个数
        int* a = new int[m]; // 动态分配数组a
        int* b = new int[k]; // 动态分配数组b
        // 读取数组a的元素
        for (int i = 0; i < m; i++) {
            cin >> a[i];
        }
        // 读取数组b的元素
        for (int i = 0; i < k; i++) {
            cin >> b[i];
        }

        // 初始化两个指针，分别指向数组a和b的起始位置
        int i = 0;
        int j = 0;
        // 当两个数组都还有元素时，进行合并操作
        while (i < m || j < k) {
            // 如果数组a和b都还有元素
            if (i < m && j < k) {
                // 比较a[i]和b[j]的大小，输出较小的元素
                if (a[i] < b[j]) {
                    cout << a[i++];
                } else {
                    cout << b[j++];
                }
                cout << " "; // 输出一个空格
            }
            // 如果数组a或b中的一个已经没有元素
            else {
                // 如果数组a还有元素，输出数组a的剩余元素
                if (i >= m) {
                    cout << b[j++];
                }
                // 如果数组b还有元素，输出数组b的剩余元素
                else if (j >= k) {
                    cout << a[i++];
                }
				if (i < m || j < k)
					cout << " ";
            }
        }
        // 每个测试用例输出结束后，输出换行符
        cout << endl;

        // 释放动态分配的数组a和b的内存
        delete[] a;
        delete[] b;
    }
    return 0; // 程序结束
}