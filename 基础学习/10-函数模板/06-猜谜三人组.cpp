/*
描述
有甲乙丙三个人喜欢让别人猜数字。他们会给别人一些提示，好让别人能够更好地猜出他们想的数字。

甲喜欢告诉别人这个数字比a大，乙喜欢告诉别人这个数字比b小，丙喜欢告诉别人这个数字的首位数是c。

当然这些条件可能并不充分，有可能有好多个数字都是满足条件的，也有可能是无解的。

现在想要知道的是，根据a、b、c三个值，到底有多少个整数是满足条件的？

输入
1个正整数n，表示测试案例的数量。（1 <= n <= 100）

每组测试案例有三个整数a、b、c（0<=a<=10亿，0<=b<=10亿，1<=c<=9），
分别代表甲乙丙三个人说的提示。

输出
针对每组案例，输出满足条件（大于a，且小于b，且首位数是c）的整数数量。每组案例输出后都要换行。

样例输入
2

5 10 4

0 20 1

样例输出
0

11

提示说明
第一组案例中，>5且<10且首位为4的数字是不存在的，所以输出0。

第二组案例中，可满足条件的数字有1、10、11、12、...、19，共11个。
*/

#include <iostream>
using namespace std;

int main() {
    long long int n, a, b, c, count, bits = 1; 
	// n为样例数，abc为用户输入，count为统计的个数，bits为统计范围（1表示1位数中c开头的个数，10表示两位数）
    cin >> n;
    while (n--) { // 循环读取n个样例
        count = 0; // 初始化总数为0
        bits = 1; // 从1位数开始统计
        cin >> a >> b >> c;
        if (a >= b) count = 0; // 如果a>=b，则区间不成立，没有c开头的
        else {
            while (c < b) { // c小于右边界
                if (c > a && c + bits <= b) count += bits;
                // 类似a~b=1~10， 或者19~30， c初始为2时，则count分别+1、+10
                if (c > a && c + bits > b) count += b % bits;
                // 类似a~b=89~99， c初始为9,到两位时就是90，则count+ （99%10）=9
                if (c <= a && c + bits > a && c + bits < b) count += (bits - a % bits - 1);
                // 类似a~b=12~20, c初始为1，到两位时是10，
                if (c <= a && c + bits > a && c + bits > b) count += (b % bits - a % bits - 1);
                // 类似a~b=12~19 c初始为1，到两位时是10，
                bits *= 10; // 开始找n+1位数字中，c开头的
                if (c == 0) break; // 如果c==0, 找完一边后直接退出
                c *= 10; // c*10， 与bits同增加一位
            }
        }
        cout << count << endl;
    }
    return 0;
}
