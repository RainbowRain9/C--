/*
问题描述
计数排序是一个非基于比较的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)>O(nlogn)  的时候其效率反而不如基于比较的排序，因为基于比较的排序的时间复杂度在理论上的下限是 O(nlogn)。

计数排序的基本思想是对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上


计数排序的基本思想是统计每个元素在序列中出现的次数，然后根据每个元素出现的次数，将元素放回到有序的序列中。具体过程如下：

统计每个元素在序列中出现的次数，得到计数数组count[]。

根据计数数组count[]，计算每个元素在有序序列中的最终位置，得到辅助数组result[]。

遍历原始序列，将每个元素放到其在辅助数组result[]中的位置上。

将辅助数组result[]复制到原始序列中。

输入描述
第1行是一个正整数m，表示后面是m个整数。

输出描述
采用计数排序，输出排序结果。

样例输入
10 2 1 5 2 4 3 0 5 3 2

样例输出
0 1 2 2 2 3 3 4 5 5

提示说明
最后不需要回车换行
*/

#include <iostream>
#include <vector>
using namespace std;

class CountSort
{
public:
    CountSort(int *a, int n)
    {
        int max = a[0];
        for (int i = 1; i < n; i++)
        {
            if (a[i] > max)
            {
                max = a[i];
            }
        }
        int count[max + 1] = {0};
        for (int i = 0; i < n; i++)
        {
            count[a[i]]++;
        }
        int result[n];
        int index = 0;
        for (int i = 0; i < max + 1; i++)
        {
            for (int j = 0; j < count[i]; j++)
            {
                result[index++] = i;
            }
        }

        for (int i = 0; i < n - 1; i++)
        {
            cout << result[i] << " ";
        }
        cout << result[n - 1];
    }
};

int main()
{
    int n;
    cin >> n;
    int a[n];
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    CountSort(a, n);
    return 0;
}