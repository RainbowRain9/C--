/*
描述
在一个类似于炉石的卡牌对战游戏中，玩家当前有m张卡牌，每张卡牌的伤害分别为d1、d2、...、dm。

玩家可以控制这m张卡牌中的一些攻击电脑，也可以控制其中一些不攻击电脑。
当然也可以全部卡牌攻击电脑，也可以全都不攻击电脑。

电脑的血量是a，每1点伤害就会扣减电脑1点血量，电脑的血量最多只会被扣减到0，
如果血量减到负数那么也算作0。

问：经过一个回合的攻击后，电脑剩余的血量有多少种可能？

输入
一个正整数n，表示有n组案例。

每组案例先是两个正整数m和a，分别表示卡牌的数量和电脑的血量。（m<=100，a<=10000）

然后是m个正整数d1、d2、...、dm，分别表示这m张卡牌的攻击力。（di<=1000）

输出
针对每组案例，输出一个整数，表示经过一个回合的攻击后，电脑剩余的血量有多少种可能。

每组案例输出完都要换行。

样例输入
2

2 100 3 5

2 100 10 100

样例输出
4

3

提示说明
第一组四种可能：100、97、95、92

第二组三种可能：100、90、0
*/

#include <iostream>
using namespace std;

int main() {
    int n; // 测试案例的数量
    cin >> n; // 读取测试案例的数量
    while (n--) { // 对于每个测试案例
        int m, a; // m表示卡牌数量，a表示电脑血量
        cin >> m >> a; // 读取卡牌数量和电脑血量
        bool* b = new bool[a + 1]{1}; // 动态分配一个布尔数组，用于跟踪可能的血量，初始化第一个元素为true（电脑初始血量）
        for (int i = 1; i <= a; i++) { // 将数组中除了第一个元素以外的其他元素初始化为false（表示血量减少后的状态）
            b[i] = false;
        }
        while (m--) { // 对于每张卡牌
            int d; // d表示卡牌的攻击力
            cin >> d; // 读取卡牌的攻击力
            for (int i = a; i >= 0; i--) { // 从高血量到低血量检查
                if (b[i] == true) { // 如果当前血量是可能的
                    if (i + d < a) { // 如果攻击后血量仍然大于等于0
                        b[i + d] = true; // 更新攻击后的血量为可能状态
                    } else { // 如果攻击后血量小于0（即超出了数组范围）
                        b[a] = true; // 标记血量为0的状态为可能（因为血量不会小于0）
                    }
                }
            }
        }
        int cnt = 0; // 计数器，用于统计可能的剩余血量状态数量
        for (int i = 0; i <= a; i++) { // 遍历数组，统计所有标记为true的血量状态
            if (b[i] == true) {
                cnt++; // 如果当前血量状态是可能的，增加计数器
            }
        }
        cout << cnt << endl; // 输出可能的剩余血量状态数量，并换行
    } // 释放动态分配的数组（注意：这里应该在循环外部释放数组，否则会造成内存泄漏）
    return 0;
}